[{"/Users/parssa/Desktop/repos/mixbot/src/index.js":"1","/Users/parssa/Desktop/repos/mixbot/src/App.js":"2","/Users/parssa/Desktop/repos/mixbot/src/reportWebVitals.js":"3","/Users/parssa/Desktop/repos/mixbot/src/TrackSelector.js":"4","/Users/parssa/Desktop/repos/mixbot/src/TrackFinder.js":"5","/Users/parssa/Desktop/repos/mixbot/src/Credentials.js":"6","/Users/parssa/Desktop/repos/mixbot/src/TrackPlayer.js":"7","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Detail.js":"8","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Listbox.js":"9","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Dropdown.js":"10","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Waveform.js":"11","/Users/parssa/Desktop/repos/mixbot/src/api/youtubeVideoContent.js":"12","/Users/parssa/Desktop/repos/mixbot/src/api/youtube.js":"13","/Users/parssa/Desktop/repos/mixbot/src/Deck.js":"14","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Knob.js":"15","/Users/parssa/Desktop/repos/mixbot/src/api/keys.js":"16","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Queue.js":"17","/Users/parssa/Desktop/repos/mixbot/src/Mixbot.js":"18","/Users/parssa/Desktop/repos/mixbot/src/Brain.js":"19","/Users/parssa/Desktop/repos/mixbot/src/helper_classes/Analyzer.js":"20"},{"size":500,"mtime":1609255907946,"results":"21","hashOfConfig":"22"},{"size":968,"mtime":1610343348487,"results":"23","hashOfConfig":"22"},{"size":362,"mtime":1609255907947,"results":"24","hashOfConfig":"22"},{"size":5705,"mtime":1610405828169,"results":"25","hashOfConfig":"22"},{"size":6269,"mtime":1610408658831,"results":"26","hashOfConfig":"22"},{"size":315,"mtime":1610336027864,"results":"27","hashOfConfig":"22"},{"size":9464,"mtime":1610390035777,"results":"28","hashOfConfig":"22"},{"size":570,"mtime":1609255907945,"results":"29","hashOfConfig":"22"},{"size":814,"mtime":1610305380930,"results":"30","hashOfConfig":"22"},{"size":550,"mtime":1609255907945,"results":"31","hashOfConfig":"22"},{"size":3782,"mtime":1609255907946,"results":"32","hashOfConfig":"22"},{"size":767,"mtime":1610248130668,"results":"33","hashOfConfig":"22"},{"size":535,"mtime":1610299742890,"results":"34","hashOfConfig":"22"},{"size":16839,"mtime":1610405648163,"results":"35","hashOfConfig":"22"},{"size":4780,"mtime":1609255907945,"results":"36","hashOfConfig":"22"},{"size":354,"mtime":1610328014835,"results":"37","hashOfConfig":"22"},{"size":608,"mtime":1610376480379,"results":"38","hashOfConfig":"22"},{"size":5018,"mtime":1610405856896,"results":"39","hashOfConfig":"22"},{"size":1120,"mtime":1610376717223,"results":"40","hashOfConfig":"22"},{"size":8257,"mtime":1610402901089,"results":"41","hashOfConfig":"22"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"11p3aqi",{"filePath":"45","messages":"46","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"44"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"44"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"44"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"44"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"44"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69","usedDeprecatedRules":"64"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"72","usedDeprecatedRules":"73"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"80","usedDeprecatedRules":"44"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"83","messages":"84","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"85","usedDeprecatedRules":"86"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"91","usedDeprecatedRules":"44"},{"filePath":"92","messages":"93","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"94","messages":"95","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"/Users/parssa/Desktop/repos/mixbot/src/index.js",[],["96","97"],"/Users/parssa/Desktop/repos/mixbot/src/App.js",["98","99","100"],"import React, {useState, useEffect} from 'react';\nimport './css_files/App.css';\nimport Mixbot from './Mixbot';\n\nimport axios from 'axios';\n\nfunction App() {\n\n    // function makeRequest() {\n    //     console.log(\"boutta make request\");\n    //     axios.create({\n    //         baseURL: 'http://localhost:8080',\n    //         headers: {}\n    //     }).get('/addEntry', {\n    //         params: {\n    //             songEntry: {\n    //                 name: \"AHA AHA AHA\"\n    //             }\n    //         },\n    //     })\n    // }\n\n    return(\n        <div className={\"body\"}>\n            <div className={\"title\"}>\n                <h1>MIXBOT</h1>\n                <div className={\"credits\"}>\n                    {/* <button onClick={() => { makeRequest() }}>Make request</button> */}\n                    <h3>An Open Source project by Parssa Kyanzadeh</h3> \n                 </div>\n            </div>\n            <Mixbot/>\n        </div>\n    );\n}\nexport default App;\n","/Users/parssa/Desktop/repos/mixbot/src/reportWebVitals.js",[],"/Users/parssa/Desktop/repos/mixbot/src/TrackSelector.js",["101","102"],"import React, { useState, useEffect } from 'react';\nimport { Credentials } from './Credentials';\nimport axios from 'axios';\nimport Listbox from \"./frontend_components/Listbox\";\nimport { Analyzer } from './helper_classes/Analyzer';\nimport TrackFinder from \"./TrackFinder\";\nimport { trackAlreadyIn, tracklistSize } from \"./Mixbot\";\n\nconst euroHouseID = \"2818tC1Ba59cftJJqjWKZi\";\n\nfunction TrackSelector({ addToQueue }) {\n    const spotify = Credentials();\n    const [token, setToken] = useState('');\n    const [genres, setGenres] = useState({ selectedGenre: '', listOfGenresFromAPI: [] });\n    const [playlist, setPlaylist] = useState({ selectedPlaylist: euroHouseID, listOfPlaylistFromAPI: [] });\n    const [tracks, setTracks] = useState({ selectedTrack: '', listOfTracksFromAPI: [] });\n    const [trackDetail, setTrackDetail] = useState(null);\n\n    useEffect(() => {\n        axios('https://accounts.spotify.com/api/token', {\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                'Authorization': 'Basic ' + btoa(spotify.ClientId + ':' + spotify.ClientSecret)\n            },\n            data: 'grant_type=client_credentials',\n            method: 'POST'\n        })\n            .then(tokenResponse => {\n                setToken(tokenResponse.data.access_token);\n            });\n\n    }, [genres.selectedGenre, spotify.ClientId, spotify.ClientSecret]);\n\n    function playlistSearchClicked(e) {\n        e.preventDefault();\n        // console.log(\"selected playlist was\" + playlist.selectedPlaylist);\n        axios(`https://api.spotify.com/v1/playlists/${playlist.selectedPlaylist}/tracks?limit=40`, {\n            method: 'GET',\n            headers: {\n                'Authorization': 'Bearer ' + token\n            }\n        }).then(tracksResponse => {\n            setTracks({\n                selectedTrack: tracks.selectedTrack,\n                listOfTracksFromAPI: tracksResponse.data.items\n            })\n        });\n    }\n\n    function selectTrack(val) {\n        const currentTracks = [...tracks.listOfTracksFromAPI];\n        const trackInfo = currentTracks.filter(t => t.track.id === val);\n        if (!trackAlreadyIn(trackInfo[0].track.name)) {\n            // console.log(\">>>\", trackInfo[0].track);\n            setTrackDetail(trackInfo[0].track);\n        } else {\n            // console.log(\"track is already in the queue\");\n        }\n    }\n\n    async function addSongToTracklist(songName, songArtists, duration, songURL, trackID, trackImage, youtubeVideoID, fromDatabase) {\n        if (!trackAlreadyIn(songName)) {\n            // console.log(\"adding: \" + songName + \"with id \" + trackID);\n            await getAudioAnalysis(trackID, songName, songArtists, duration, songURL, trackImage, youtubeVideoID, fromDatabase);\n        } else {\n            // console.log(\"track is already in the queue\");\n            setTrackDetail(null);\n        }\n    }\n\n    async function checkForSongAnalysis(songID) {\n        // console.log(\"boutta check songAnalysis\");\n        let result = null;\n        if (songID) {\n            result = await axios.get('http://localhost:8080/checkEntryAnalysis', {\n                params:\n                {\n                    data: songID\n                }\n            });\n        }\n        return result.data;\n    }\n\n    async function addSongAnalysisToDatabase(songID, songAnalysis) {\n        let dbAnalysis = {\n            songID: songID,\n            analysis: songAnalysis\n        }\n        await axios.get('http://localhost:8080/addAnalysis', {\n            params:\n            {\n                data: dbAnalysis\n            }\n        });\n\n        \n    }\n\n    const getAudioAnalysis = async (id, songName, songArtists, duration, songURL, trackImage, youtubeVideoID, fromDatabase) => {\n        // console.log(\"song id is \" + id);\n\n        // 1) Check if DB already contains songAnalysis\n        let analysisInDB = await checkForSongAnalysis(id);\n        \n        // console.log(\">>>> !> >!> >!>:\", analysisInDB);\n        // console.log(\"analysis in db??:\", analysisInDB.data);\n\n        // 2) If song does not contain\n        if (!analysisInDB.data) {\n            let rawAnalysis = await axios(`https://api.spotify.com/v1/audio-analysis/${id}`, {\n                method: 'GET',\n                headers: {\n                    'Authorization': 'Bearer ' + token\n                }\n            });\n\n            // Clean up the spotify data\n            let songData = rawAnalysis.data;\n            let analyzer = new Analyzer();\n            let analyzedData = analyzer.analyzeSong(songData);\n            analysisInDB = analyzedData;\n            addSongAnalysisToDatabase(id, analyzedData);\n        }\n        // console.log(\">>>>>>>>>>>>>>>>..... analysis in db sending out!\", analysisInDB);\n        addToQueue(songName, songArtists, duration, songURL, analysisInDB, trackImage, id, youtubeVideoID, fromDatabase);\n        setTrackDetail(null);\n    }\n\n    return (\n        <div>\n            <form onSubmit={playlistSearchClicked}>\n                {tracklistSize() === 0 && <button type='submit' className=\"begin-mix\">BEGIN MIX</button>}\n                <div style={{ marginTop: \"4em\" }}>\n                    <Listbox items={tracks.listOfTracksFromAPI} clicked={selectTrack} />\n                    {trackDetail && <TrackFinder name={trackDetail.name}\n                        artists={trackDetail.artists}\n                        duration_ms={trackDetail.duration_ms}\n                        trackID={trackDetail.id}\n                        trackImage={trackDetail.album.images[1]}\n                        foundSong={addSongToTracklist} />}\n                </div>\n            </form>\n        </div>\n    );\n}\n\nexport default TrackSelector;\n","/Users/parssa/Desktop/repos/mixbot/src/TrackFinder.js",["103","104","105","106","107"],"import React, { useEffect, useState } from 'react';\nimport youtubeApi from './api/youtube'\nimport videoDetailFinder from './api/youtubeVideoContent'\nimport { parse, end, toSeconds, pattern } from 'iso8601-duration';\nimport axios from 'axios';\n\nconst baseURL = 'http://localhost:8080';\n/**\n * This class handles finding a track based on song name, artists, and duration\n * and calls the foundSong prop when a song has been found.\n *\n * @param name: Name of the Song\n * @param artists: An array of artist objects\n * @param duration_ms: The duration of the song in milliseconds\n * @param foundSong: A prop that gets called when song has been found\n * @param trackID: id of the spotify song\n */\nlet lastChosenID = \"\";\nlet fromDatabase = false;\nexport default function TrackFinder({ name, artists, duration_ms, foundSong, trackID, trackImage }) {\n\n    // const [songName, setSongName] = useState(name);\n    // const [songArtists, setSongArtists] = useState(artists);\n    // const [duration, setDuration] = useState(duration_ms);\n    const [chosenVideoID, setChosenVideoID] = useState(\"\");\n\n    function createSearchQuery() {\n        let artistNames = [];\n        artists.forEach(e => {\n            const thisName = e.name;\n            if (thisName) {\n                artistNames.push(thisName)\n            }\n        });\n        let searchQuery = name + \" by \" + artistNames[0];\n        return searchQuery;\n    }\n\n\n    async function videosSearch(search) {\n        const response = await youtubeApi.get(\"/youtubeSearch\", { // TODO CHANGE THIS TO SERVER\n            params: {\n                q: search\n            }\n        })\n        return response;\n    }\n\n    async function videoDetail(videoID) {\n        const response = await videoDetailFinder.get(\"/youtubeDetail\", {\n            params: {\n                id: videoID\n            }\n        })\n        return response;\n    }\n\n    /**\n     * Searches YouTube for song using search query, breaks when found is song\n     * @param searchQuery\n     * @returns {Promise<void>}\n     */\n    async function getYoutubeVideo(searchQuery) {\n        videosSearch(searchQuery).then(async e => {\n            const videoList = e.data.items;                                                     // a list of videos                 \n            for (let video = 0; video < videoList.length; video++) {                            // for each video in the videoList...\n                const thisDetails = await videoDetail(videoList[video].id.videoId);             // Get details...\n                const thisDur = toMilli(thisDetails.data.items[0].contentDetails.duration);     // Get duration from details...\n                if (Math.abs(duration_ms - thisDur) <= 1000) {                                     // If the duration is what we're looking for...\n                    setChosenVideoID(videoList[video].id.videoId); // TODO FIX THIS OMG THIS IS AN ABSOLUTE ABUSE OF STATE.\n                    break;\n                }\n            }\n            console.log(\"??????????????????????????????                                hit here\");\n            if (!chosenVideoID) {\n                console.log(\"COULDNT FIND A SONG!!!!!!!\");\n                let whitelistObj = {\n                    songID: trackID,\n                    songName: name,\n                    songArtists: artists,\n                    expectedDuration: duration_ms,\n                }\n                await addToWhitelist(whitelistObj); // ! TODO TEST THISSS <<<<<<<<<<<<<<<<<<<<<<<<\n            }\n        })\n    }\n\n    /**\n     * Helper function for converting ISO8 8601 time to milliseconds\n     * @param ISO: ISO time\n     * @returns {the ISO time in milliseconds}\n     */\n    function toMilli(ISO) {\n        return toSeconds(parse(ISO)) * 1000;\n    }\n\n    /**\n     * This effect triggers when the chosenVideoID is\n     * found, and then get the URL for mp3 download\n     *\n     * Since this effect gets called over once for the\n     * same video being found sometimes, it will not\n     * convert the video to mp3 if it has already been\n     * called once for this current song\n     * >> “ \"lastChosenID === \"\" ”\n     */\n    useEffect(() => {\n\n        if (chosenVideoID && lastChosenID === \"\") {\n            lastChosenID = chosenVideoID;\n            videoIDtoMP3(chosenVideoID);\n        }\n\n    }, [chosenVideoID])\n\n    useEffect(() => {          // TODO FIX WHEN AVAILABLE\n        // setSongArtists(artists);\n        // setSongName(name);\n        // setDuration(duration_ms);\n        // console.log(\"use effect for checking entereed\");\n        async function findYoutubeID() {\n            // console.log(\"entered async bit\");\n            const result = await checkDatabase();\n            lastChosenID = \"\";\n            if (result === \"\") {\n                // console.log(\"Going to find the song\");\n                fromDatabase = false;\n                const search = createSearchQuery();\n                await getYoutubeVideo(search);\n            } else {\n                // console.log(\"Got it from the DB!\");\n                fromDatabase = true;\n                setChosenVideoID(result.videoID);\n            }\n        }\n\n        findYoutubeID();\n\n    }, [name, artists, duration_ms]);\n\n    async function checkDatabase() { // TODO MOVE THIS INTO IT'S OWN CLASS\n        let result = null;\n        if (trackID) {\n            result = await axios.get(baseURL + '/checkForEntry', {\n                params:\n                {\n                    data: trackID\n                }\n            });\n        }\n        return result.data;\n    }\n\n    async function addToWhitelist(whitelistObj) { // TODO MOVE THIS INTO IT'S OWN CLASS\n        console.log(\"ADDING TO WHITELIST>>>\");\n        await axios.get(baseURL + '/whitelistEntry', {\n            params:\n            {\n                data: whitelistObj\n            }\n        });\n    }\n\n    async function videoIDtoMP3(videoID) {\n        videoDetailFinder.get('/youtubeMp3', {\n            params: {\n                id: videoID\n            }\n        }).then(response => {\n            let audioFormats = response.data;\n            foundSong(name, artists, duration_ms, audioFormats[0].url, trackID, trackImage, videoID, fromDatabase); // ! ADD FROMDATABASE\n            setChosenVideoID(\"\");\n        });\n    }\n\n    return null;\n}","/Users/parssa/Desktop/repos/mixbot/src/Credentials.js",["108"],"const cred1 = {\n    ClientId: '2f960da39c8b42d9a8dc394d02b97db0',\n    ClientSecret: '860fabcadd034f1d9368e7ca7791de73'\n}\n\n\nconst cred2 = {\n    ClientId: '75cbbf8c1ff14b9abe3cbfe6924fb5f0',\n    ClientSecret: 'da55e142b302460cab9b737153b93eb4'\n}\n\n\nfunction Credentials() {\n    return cred2;\n}\n\nexport { Credentials };","/Users/parssa/Desktop/repos/mixbot/src/TrackPlayer.js",["109","110","111","112","113","114"],"import React, { useEffect, useState } from 'react';\nimport Deck from \"./Deck\";\nimport './css_files/Queue.scss';\nimport { loadTrack, nextSongInQueue, thoughtType } from \"./Mixbot\";\n\n// let deck1playtime = NaN;\n// let deck2playtime = NaN;\n\nlet deck1startTime = 0;\nlet deck2startTime = 0;\n\nlet lastTrackSet = 0;\nlet mainTrack = 0;\n\nlet deck1lastBar = 0;\nlet deck2lastBar = 0;\n\nexport default function TrackPlayer({newThought}) {\n    const [clock, setClock] = useState();\n\n    const [deck1Song, setDeck1Song] = useState('');\n    const [deck2Song, setDeck2Song] = useState('');\n\n    const [deck1BPM, setDeck1BPM] = useState(0);\n    const [deck2BPM, setDeck2BPM] = useState(0);\n\n    const [deck1playback, setDeck1playback] = useState(1);\n    const [deck2playback, setDeck2playback] = useState(1);\n\n    const [deck1prepared, setDeck1prepared] = useState(false);\n    const [deck2prepared, setDeck2prepared] = useState(false);\n\n    const [deck1Playing, setDeck1Playing] = useState(false);\n    const [deck2Playing, setDeck2Playing] = useState(false);\n\n    const [deck1offset, setDeck1offset] = useState(0);\n    const [deck2offset, setDeck2offset] = useState(0);\n\n    useEffect(() => {\n        console.log(\"-----------------player did update!-----------------\");\n        if (!clock) {\n            let newClock = new AudioContext();\n            setClock(newClock);\n        } \n    })\n\n    useEffect(() => {\n        if (nextSongInQueue() !== null) {\n            console.log(\">>> theres a song in the queue!\", nextSongInQueue());\n            if ((deck1BPM == 0) && (deck1Song == '')) {\n                console.log(\">> putting it in track a\");\n                loadTrackA();\n            } else if ((deck2BPM == 0) && (deck2Song == '')) {\n                console.log(\">> putting it in track b\");\n                loadTrackB();\n            }\n        }\n    })\n\n    function loadTrackA() {\n        let newSong = loadTrack();\n        setDeck1prepared(false);\n        setDeck1Playing(false);\n        if (newSong !== null) {\n            console.log(\"new\");\n            console.log(newSong);\n            setDeck1BPM(Math.round(newSong.songAnalysis.tempo)) // terribly sus\n            if (deck2Song === '') {\n                setDeck1playback(1);\n            } else {\n                if (deck2BPM !== 0) {\n                    let ratio = (deck2BPM / newSong.songAnalysis.tempo).toPrecision(5);\n                    setDeck1playback(ratio);\n                } else {\n                    setDeck1playback(1);\n                }\n            }\n            console.log(\"> , --------------------------->> \", newSong);\n            let think = \"Put \" + newSong.songName + \" on Deck A\";\n            newThought(think);\n            setDeck1Song(newSong);\n        }\n        else {\n            console.log(\"new song was null\");\n        }\n    }\n\n    function loadTrackB() {\n        let newSong = loadTrack();\n        setDeck2prepared(false);\n        setDeck2Playing(false);\n        if (newSong !== null) {\n            setDeck2BPM(Math.round(newSong.songAnalysis.tempo)) // terribly sus\n            console.log(\">>>>>            here comes the next song\", newSong);\n            if (deck1Song === '') {\n                setDeck2playback(1);\n            } else {\n                if (deck1BPM !== 0) {\n                    let ratio = (deck1BPM / Math.round(newSong.songAnalysis.tempo)).toPrecision(5);\n                    setDeck2playback(ratio);\n                } else {\n                    setDeck2playback(1);\n                }\n            }\n            let think = \"Put \" + newSong.songName + \" on Deck B\";\n            newThought(think);\n            setDeck2Song(newSong)\n        } else {\n            console.log(\"new song was null\");\n        }\n    }\n\n    function deckOneReady() {\n        if (!deck1prepared) {\n            setDeck1prepared(true);\n            console.log(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SETTING D1READY\");\n            if (!deck2Playing) {\n                console.log(\"telling deck 1 to play\");\n                setDeck1Playing(true);\n            }\n        }\n    }\n\n    function deckTwoReady() {\n        if (!deck2prepared) {\n            setDeck2prepared(true);\n            console.log(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SETTING D2READY\");\n            if (!deck1Playing) {\n                console.log(\"telling deck 2 to play\");\n                setDeck2Playing(true);\n            }\n        }\n    }\n\n    // function playDeck2SongScheduled(timeoutValue) {\n    //     console.log(\"setting timeout for:\", timeoutValue);\n    //     setTimeout(function () {\n    //         console.log(clock.currentTime, deck2playtime);\n    //         console.log(\"checkin time bois\", deck2playtime - clock.currentTime);\n    //         if (deck2playtime - clock.currentTime <= 0) {\n    //             deck2startTime = deck2playtime - clock.currentTime;\n    //             setDeck2Playing(true);\n    //         } else {\n    //             console.log(deck2playtime - clock.currentTime);\n    //             if ((deck2playtime - clock.currentTime) <= 0.5) {\n    //                 console.log(\"case a \");\n    //                 playDeck2SongScheduled(500);\n    //             } else {\n    //                 console.log(\"case b \");\n    //                 playDeck2SongScheduled((deck2playtime - clock.currentTime) / 2);\n    //             }\n    //         }\n    //     }, timeoutValue)\n    // }\n\n    function playTrackTwo() {\n        if (deck2prepared) {\n            console.log(\"+++ deck TWO is prepared, gonna play it!\");\n            setDeck2Playing(true);\n            setDeck2prepared(false);\n            if (lastTrackSet === 0) {\n                lastTrackSet = 2;\n                mainTrack = 1;\n            }\n        }\n    }\n\n    function playTrackOne() {\n        if (deck1prepared) {\n            console.log(\"+++ deck ONE is prepared, gonna play it!\");\n            setDeck1Playing(true);\n            setDeck1prepared(false);\n            if (lastTrackSet === 0) {\n                lastTrackSet = 1;\n                mainTrack = 1;\n            }\n\n        }\n    }\n\n    function hitBarD1() {\n        deck1lastBar = clock.currentTime;\n        if (deck2Playing) {\n            console.log(\"DECK1\", deck1offset);\n            setDeck1offset(deck2lastBar - deck1lastBar);\n        }\n    }\n\n    function hitBarD2() {\n        deck2lastBar = clock.currentTime;\n        if (deck1Playing) {\n            console.log(\"DECK2\", deck2offset);\n            setDeck2offset(deck1lastBar - deck2lastBar);\n        }\n    }\n\n    function changeTrackA() {\n        mainTrack = 2;\n        setDeck2playback(1);\n        loadTrackA();\n    }\n\n    function changeTrackB() {\n        mainTrack = 1;\n        setDeck1playback(1);\n        loadTrackB();\n    }\n\n    return (\n        <>\n            <div className={\"djboard\"}>\n                <div className={\"boardpanel\"} style={deck1Playing ? { boxShadow: \"0 3px 100px rgba(255, 99, 71, 0.3)\" } : { boxShadow: \"0 0 0 rgba(255, 99, 71, 0.3)\" }}>\n                    <h3>DECK A</h3>\n                    {deck1Song !== '' && <Deck\n                        thisSong={deck1Song.songURL}\n                        songName={deck1Song.songName}\n                        songArtist={deck1Song.songArtists[0].name}\n                        songImage={deck1Song.trackImage}\n                        songAnalysis={deck1Song.songAnalysis}\n                        playbackRate={deck1playback}\n                        prepared={deckOneReady}\n                        play={deck1Playing}\n                        startTime={deck1startTime}\n                        playOtherTrack={playTrackTwo}\n                        hitBar={hitBarD1}\n                        offset={deck1offset}\n                        deckName={\"Deck A\"}\n                        finished={changeTrackA}\n                        recommendedVolume={1}\n                        shouldSync={mainTrack !== 1}\n                        otherReady={deckTwoReady}\n                        waveformID={\"waveformA\"}\n                        bpm={deck1BPM}\n                        newThought={newThought}\n                    />\n                    }\n\n                </div>\n                <div className={\"boardpanel\"} style={deck2Playing ? { boxShadow: \"0 3px 100px rgba(255, 99, 71, 0.3)\" } : { boxShadow: \"0 0 0 rgba(255, 99, 71, 0.3)\" }}>\n                    <h3 style={{ textAlign: 'right' }}>DECK B</h3>\n                    {deck2Song !== '' && <Deck\n                        thisSong={deck2Song.songURL}\n                        songName={deck2Song.songName}\n                        songArtist={deck2Song.songArtists[0].name}\n                        songImage={deck2Song.trackImage}\n                        songAnalysis={deck2Song.songAnalysis}\n                        playbackRate={deck2playback}\n                        prepared={deckTwoReady}\n                        play={deck2Playing}\n                        startTime={deck2startTime}\n                        playOtherTrack={playTrackOne}\n                        hitBar={hitBarD2}\n                        offset={deck2offset}\n                        deckName={\"Deck B\"}\n                        finished={changeTrackB}\n                        recommendedVolume={1}\n                        shouldSync={mainTrack !== 2}\n                        otherReady={deckOneReady}\n                        waveformID={\"waveformB\"}\n                        bpm={deck2BPM}\n                        newThought={newThought}\n                    />}\n                </div>\n            </div>\n        </>\n    );\n}","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Detail.js",[],["115","116"],"/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Listbox.js",[],"/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Dropdown.js",["117"],"import React, {useState} from 'react';\n\nconst Dropdown = props => {\n\n    const dropdownChanged = e => {\n        props.changed(e.target.value);\n\n    }\n\n    return (\n        <div className=\"dropdown\">\n            <label>{props.label}</label>\n            <select value={props.selectedValue} onChange={dropdownChanged}>\n                <option key={0}>Select...</option>\n                {props.options.map((item, idx) => <option key={idx + 1} value={item.id}>{item.name}</option>)}\n            </select>\n        </div>\n    );\n}\n\nexport default Dropdown;\n","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Waveform.js",["118","119","120"],"import React, { useEffect, useRef, useState } from \"react\";\nimport WaveSurfer from 'wavesurfer.js';\n\n//https://codesandbox.io/s/audio-player-with-wavesurferjs-react-bd499?from-embed=&file=/src/Waveform.js:0-60\n\nexport default function Waveform({ url, onPositionChange, isPlaying, audioCtx, lowpassNum }) {\n    const waveformRef = useRef(null);\n    const wavesurfer = useRef(null);\n    const [playing, setPlay] = useState(false);\n    const [volume, setVolume] = useState(0.5);\n    const formWaveSurferOptions = ref => ({\n        container: ref,\n        waveColor: \"#beb9b9\",\n        progressColor: \"#9a68c9\",\n        cursorColor: \"#dac4f0\",\n        hideScrollbar: true,\n        responsive: true,\n        partialRender: true,\n        normalize: true,\n        height:200\n    });\n\n    // create new WaveSurfer instance\n    // On component mount and when url changes\n    useEffect(() => {\n        setPlay(false);\n\n        const options = formWaveSurferOptions(waveformRef.current);\n        wavesurfer.current = WaveSurfer.create(options);\n        wavesurfer.current.load(url.src);\n        wavesurfer.current.on(\"ready\", function() {\n            // https://wavesurfer-js.org/docs/methods.html\n            // wavesurfer.current.play();\n            // setPlay(true);\n\n            // make sure object still available when file loaded\n            if (wavesurfer.current) {\n                wavesurfer.current.setVolume(volume);\n                setVolume(volume);\n            }\n            let lowpass = wavesurfer.backend.ac.createBiquadFilter();\n            lowpass.type = \"lowpass\";\n            lowpass.frequency.value = 10;\n            wavesurfer.current.backend.setFilter(lowpass);\n        });\n\n        // Removes events, elements and disconnects Web Audio nodes.\n        // when component unmount\n        return () => wavesurfer.current.destroy();\n    }, [url]);\n\n    useEffect(() => {\n        console.log(\"!!!\")\n        handlePlayPause();\n        console.log(wavesurfer.current.getFilters());\n        // if (isPlaying !== playing) {\n        //     handlePlayPause();\n        // }\n        // wavesurfer.current.on('audioprocess', function () {\n        //     // $('.waveform__counter').text( formatTime(wavesurfer.getCurrentTime()) );\n        //     // console.log(wavesurfer.current.getCurrentTime());\n        //     // console.log(\"--\")\n        //     onPositionChange(wavesurfer.current.getCurrentTime());\n        //\n        // });\n    }, [isPlaying]);\n\n    useEffect( () => {\n        console.log(\"lowpass\", lowpassNum);\n\n    }, [lowpassNum])\n\n\n    const handlePlayPause = () => {\n        console.log(\"switching this\");\n        setPlay(isPlaying);\n        wavesurfer.current.playPause();\n    };\n\n    // const onVolumeChange = e => {\n    //     const { target } = e;\n    //     const newVolume = +target.value;\n    //\n    //     if (newVolume) {\n    //         setVolume(newVolume);\n    //         wavesurfer.current.setVolume(newVolume || 1);\n    //     }\n    // };\n\n    return (\n        <div className={\"waveform-comp\"}>\n            <div id=\"waveform\" ref={waveformRef} />\n            <div className=\"controls\">\n                {/*<button onClick={handlePlayPause}>{!playing ? \"Play\" : \"Pause\"}</button>*/}\n                {/*<input*/}\n                {/*    type=\"range\"*/}\n                {/*    id=\"volume\"*/}\n                {/*    name=\"volume\"*/}\n                {/*    // waveSurfer recognize value of `0` same as `1`*/}\n                {/*    //  so we need to set some zero-ish value for silence*/}\n                {/*    min=\"0.01\"*/}\n                {/*    max=\"1\"*/}\n                {/*    step=\".025\"*/}\n                {/*    onChange={onVolumeChange}*/}\n                {/*    defaultValue={volume}*/}\n                {/*/>*/}\n            </div>\n        </div>\n    );\n}",["121","122"],"/Users/parssa/Desktop/repos/mixbot/src/api/youtubeVideoContent.js",[],"/Users/parssa/Desktop/repos/mixbot/src/api/youtube.js",[],"/Users/parssa/Desktop/repos/mixbot/src/Deck.js",["123","124","125","126","127","128","129","130","131","132","133"],"import React, { Component } from 'react';\nimport Knob from './frontend_components/Knob';\nimport WaveSurfer from 'wavesurfer.js';\nimport RegionPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.regions.min.js';\nimport './css_files/Deck.scss';\nimport { SectionType } from './helper_classes/Analyzer';\nimport { thoughtType } from './Mixbot';\n\nlet xhr = { cache: 'default', mode: 'cors', method: 'GET', credentials: 'same-origin', redirect: 'follow', referrer: 'client', headers: [{ 'Access-Control-Allow-Origin': '*' }] };\n\nexport default class Deck extends Component {\n    constructor(props) {\n        super(props);\n        console.log(\"entered constructor call!\");\n        this.state = {\n            pos: 0,\n            locked: false,\n            scheduledDemise: false,\n            currSec: \"NOT PLAYING\",\n            playing: false,\n            trackName: this.props.songName,\n            trackArtist: this.props.songArtist,\n            audioCtx: new AudioContext(),\n            audioSettings: {\n                gain: 1,\n                lowpassF: 11000,\n                highpassF: 0,\n                high: 1,\n                mid: 1,\n                low: 1,\n                playbackRate: this.props.playbackRate\n            },\n            currSectionAnalysis: {\n                begin: NaN,\n                endpoint: NaN,\n                comparisonLoudness: NaN,\n                differential: NaN,\n                sectionConfidence: NaN,\n                conformedBegin: NaN,\n                conformedEnd: NaN,\n                oBegin: NaN,\n                oEnd: NaN,\n                sectionColor: `rgb(255,255,255)`,\n                goodForMix: false,\n                isBest: false\n            },\n            startingPos: 0\n        };\n\n        this.waveSurferOptions = {\n            container: `#${this.props.waveformID}`,\n            waveColor: \"#ffffff\",\n            cursorColor: \"tomato\",\n            hideScrollbar: true,\n            normalize: true,\n            height: 70,\n            barWidth: 1,\n            barHeight: 0.5, // the height of the wave\n            barRadius: 2,\n            plugins: [\n                RegionPlugin.create(),\n            ],\n            xhr: xhr\n        }\n\n        this.lastAdjustTime = 0;\n        this.synced = false;\n        this.fadingOut = false;\n        this.fadingIn = false;\n        this.totalOffset = 0;\n        this.numSuccessful = 0;\n        this.numDropsPassed = 0;\n\n        this.playPause = this.playPause.bind(this);\n        this.fadeOutSong = this.fadeOutSong.bind(this);\n        this.changeFilter = this.changeFilter.bind(this);\n        this.changeGain = this.changeGain.bind(this);\n        this.reconnectAudio = this.reconnectAudio.bind(this);\n        this.handlePosChange = this.handlePosChange.bind(this);\n    }\n\n    componentDidMount() {\n        console.log(\"|| ---- COMPONENT DID MOUNT ---- ||\", this.props.deckName);\n        this.waveform = WaveSurfer.create(this.waveSurferOptions);\n\n        this.waveform.on('error', e => {\n            console.log(\"hit error:\", e);\n        })\n      \n        console.log(\"MOUNT THISSONG>>>\",this.props.thisSong);\n        // let dummy = new Audio(this.props.thisSong);\n        // console.log(\">>>!!!>>>\", dummy.src);\n        // console.log(\">>>>!!!!???\", dummy.src === this.props.thisSong);\n        this.waveform.load(this.props.thisSong);\n\n        // console.log(this.props.thisSong);\n        // let ooga = this.props.thisSong;\n        // console.log(\"ooga is:\", ooga);\n        // console.log(\"song src WAS:\", song.src);\n        // // song.src = this.props.thisSong;\n        // song.crossOrigin = \"anonymous\";\n        // console.log(\"loading song in mount >>>!\", this.props.thisSong);\n        \n        // this.waveform.load(\"http://ia902606.us.archive.org/35/items/shortpoetry_047_librivox/song_cjrg_teasdale_64kb.mp3\");\n        console.log(\"loaded song\", this.waveform.src);\n        this.waveform.setPlaybackRate(this.props.playbackRate);\n        this.reconnectAudio();\n    }\n\n    componentDidUpdate(prevProps) {\n        console.log(\"||| ---- COMPONENT DID UPDATE ---- |||\", this.props.deckName);\n        console.log(\"TRACK IMG:\", this.props.songImage)\n        if (this.props.thisSong !== prevProps.thisSong) { // TODO LEFT OFF HERE, YOU WERE TRYING TO MAKE SWITCHING SONGS ON A SINGLE DECK WORK BC IT KEEPS PLAYING THE OLD ONE ALSO REGIONS AREN\"T DISAPPEARING\n            console.log(\"|| -- THE SONG CHANGED -- ||\", this.props.deckName);\n            this.waveform.pause();\n\n            this.synced = false;\n            this.numSuccessful = 0;\n            this.totalOffset = 0;\n            this.fadingOut = false;\n            this.fadingIn = false;\n            this.numDropsPassed = 0;\n\n            this.waveform.destroy();\n\n            this.waveform = WaveSurfer.create(this.waveSurferOptions);\n            this.waveform.on('loading', e => {\n                console.log(\"loading:\", e);\n            })\n\n            this.waveform.on('error', e => {\n                console.log(\"hit error:\", e);\n            })\n\n            console.log(\"loading song in update >>>!\", this.props.thisSong);\n            let dummy = new Audio(this.props.thisSong);\n            this.waveform.load(dummy.src);\n            this.waveform.setPlaybackRate(this.props.playbackRate);\n\n            this.reconnectAudio();\n        } else {\n            console.log(\"SONG DIDN'T CHANGE\");\n        }\n\n        if (this.state.audioCtx.state !== 'suspended') {\n            if (this.props.play !== this.waveform.isPlaying()) {\n                if (!this.props.play) {\n                    console.log(\"~~~ SHOULD BE PAUSED NGL ~~~\");\n                    this.waveform.pause();\n                } else {\n                    this.playPause();\n                }\n            }\n        }\n\n        if (!this.props.shouldSync) {\n            this.synced = true; // If this is the main track, don't sync it\n            this.waveform.setPlaybackRate(1);\n        }\n\n        // If the offset between tracks is under 0.1 seconds and this is playing, this track is succesful\n        // ! The margin of error of 0.1s is needed due to timing issues with WebAudio\n        if (Math.abs(this.props.offset) < 0.1 && this.waveform.isPlaying()) {\n            this.numSuccessful++;\n            if (Math.abs(this.props.offset) < 0.05) this.numSuccessful++;\n            if (this.numSuccessful >= 3) {\n                this.synced = true;\n            }\n        }\n\n        /**\n         * IF:\n         *  1) New offset passed in\n         *  2) It has been over 5 seconds since the last time it was adjusted\n         */\n        if (this.props.offset !== prevProps.offset &&\n            this.waveform.getCurrentTime() - this.lastAdjustTime > 5 &&\n            Math.abs(this.props.offset) >= 0.05 &&\n            !this.synced) {\n            this.numSuccessful = 0;\n            console.log(this.props.deckName, \"-> about to sync\");\n            if (this.waveform.getCurrentTime() + this.props.offset > 1 && this.props.offset != 0) {\n                this.lastAdjustTime = this.waveform.getCurrentTime();\n                let adjustedOffset = this.props.offset;\n                this.totalOffset = this.props.offset;\n                console.log(\"%%%   \", this.props.deckName, \"total offset:\", this.totalOffset);\n                let desiredTime = this.waveform.getCurrentTime() + this.props.offset;\n                console.log(\"%%%   \", this.props.deckName, \" song pos was at:\", this.waveform.getCurrentTime(), \"we need:\", desiredTime);\n                this.waveform.pause();\n                this.waveform.skip(adjustedOffset);\n                this.waveform.playPause();\n                console.log(\"%%%   \", this.props.deckName, \" now we are at:\", this.waveform.getCurrentTime(), \"difference is:\", desiredTime - this.waveform.getCurrentTime(), \"offset diff:\", (this.props.offset - desiredTime - this.waveform.getCurrentTime()));\n            } else {\n                console.log(this.props.deckName, \"-> didn't sync \");\n            }\n        }\n    }\n\n    reconnectAudio() {\n        // this.state.audi1oElement.crossOrigin = \"anonymous\";\n        console.log(\"reconnecting audio\");\n        // LOWPASS\n        let lowpass = this.waveform.backend.ac.createBiquadFilter();\n        lowpass.frequency.value = this.state.audioSettings.lowpassF || 11000;\n        lowpass.type = \"lowpass\";\n        lowpass.Q.value = 5;\n        this.setState({\n            lowpassNode: lowpass\n        });\n\n        // HIGHPASS\n        let highpass = this.waveform.backend.ac.createBiquadFilter();\n        highpass.frequency.value = this.state.audioSettings.highpassF || 0;\n        highpass.type = \"highpass\";\n        highpass.Q.value = 5;\n        this.setState({\n            highpassNode: highpass\n        });\n\n        // GAIN\n        let gain = this.waveform.backend.ac.createGain();\n        gain.value = this.state.audioSettings.gain || 0.01;\n        this.setState({\n            gainNode: gain\n        });\n        this.waveform.backend.setFilter(lowpass, highpass);\n\n        if (this.props.songAnalysis !== 'NOTFOUND') {\n            let analyzed = this.props.songAnalysis.songSections;\n            \n            analyzed.forEach(section => {\n                let region = {\n                    start: section.begin,\n                    end: section.endpoint,\n                    attributes: section.computed,\n                    data: section,\n                    color: section.sectionColor,\n                    drag: false,\n                    resize: false,\n                }\n                this.waveform.addRegion(region);\n            })\n\n            let bars = this.props.songAnalysis.bars;\n            bars.forEach(b => {\n                this.waveform.addRegion(b);\n            })\n            this.setState({\n                startingPos: this.props.songAnalysis.startPos\n            })\n        }\n        this.waveform.on('region-in', e => {\n            this.props.hitBar();\n            if (e.data.sectionType !== undefined) { // has data!\n                if (e.data.sectionType === SectionType.DROP) {\n                    this.numDropsPassed++;\n                }\n            }\n        })\n\n        this.waveform.on('region-out', e => {\n            let thisSection = e.data;\n            let computed = thisSection.computed;\n            if (computed) {\n                this.setState({\n                    currSec: thisSection.sectionType,\n                    currSectionAnalysis: {\n                        begin: thisSection.begin,\n                        endpoint: thisSection.endpoint,\n                        comparisonLoudness: computed.comparisonLoudness,\n                        differential: computed.differential,\n                        sectionConfidence: computed.sectionConfidence,\n                        conformedBegin: computed.comformedBegin,\n                        conformedEnd: computed.comformedEnd,\n                        oBegin: computed.oBegin,\n                        oEnd: computed.oEnd,\n                        sectionColor: thisSection.sectionColor,\n                        goodForMix: thisSection.goodForMix,\n                        isBest: thisSection.isBest,\n                        sizeComparison: thisSection.sizeComparison,\n                        is32: thisSection.is32\n                    }\n                })\n\n                if (thisSection.sectionType === SectionType.DROP && this.numDropsPassed > 0 && this.props.otherReady) {\n                    this.props.playOtherTrack();\n                    // TODO ADD BRAIN\n                    let think = \"Fading out \" + this.props.deckName;\n                    this.props.newThought(think, thoughtType.MIX);\n                    this.fadeOutSong();\n                }\n            } else {\n                this.props.hitBar();\n            }\n        });\n\n        this.waveform.on('ready', e => {\n            console.log(\"------ READY TO GO! 1 ------\");\n            this.state.audioCtx.resume();\n            if (!this.waveform.isPlaying()) {\n                this.playPause();\n                this.props.prepared();\n            }\n            this.waveform.setVolume(0.1);\n        });\n\n        this.waveform.on('play', e => {\n            console.log(this.props.deckName, \" JUST STARTED PLAYING GONNA FADE IT IN NOW OK\");\n            this.waveform.setVolume(0.1);\n\n            let think = \"Fading in \" + this.props.deckName;\n            this.props.newThought(think, thoughtType.MIX);\n            this.fadeInSong();\n        })\n\n    }\n\n    playPause() {\n        // check if context is in suspended state (autoplay policy)\n        if (this.state.audioCtx.state === 'suspended') {\n            this.state.audioCtx.resume();\n\n        }\n        this.waveform.play(this.state.startingPos);\n        if (this.state.playing !== this.waveform.isPlaying()) {\n            this.setState({\n                playing: this.waveform.isPlaying()\n            });\n        }\n    }\n\n    changeFilter(amount) {\n        if (amount <= 14000) {\n            this.state.audioSettings.lowpassF = amount;\n            this.state.lowpassNode.frequency.value = amount;\n        } else if (amount >= 20000) {\n            let highpassAmount = amount - 20000;\n            this.state.audioSettings.highpassF = highpassAmount;\n            this.state.highpassNode.frequency.value = this.state.audioSettings.highpassF;\n        } else {\n            this.state.audioSettings.lowpassF = 30000;\n            this.state.lowpassNode.frequency.value = this.state.audioSettings.lowpassF;\n            this.state.audioSettings.highpassF = 0;\n            this.state.highpassNode.frequency.value = this.state.audioSettings.highpassF;\n        }\n    }\n\n    changeGain(amount) {\n        this.setState({\n            audioSettings: {\n                gain: (amount / 100).toPrecision(2)\n            }\n        })\n        this.waveform.setVolume((amount / 100).toPrecision(2) || 1);\n    }\n\n    handlePosChange(e) {\n        this.setState({\n            pos: e\n        });\n    }\n\n    fadeOutSong() {\n        // console.log(\"fading out\");\n        this.fadingOut = true;\n        this.waveform.setVolume(lerp(this.waveform.getVolume(), 0, Math.max(this.waveform.getVolume() / 3), 0.1, this.props.deckName));\n        this.state.lowpassNode.frequency.value -= (this.state.lowpassNode.frequency.value / 10);\n        if (this.waveform.getVolume() < 0.2) this.waveform.setVolume(this.waveform.getVolume() - 0.03);\n        if (this.waveform.getVolume() > 0.01) {\n            setTimeout(() => {\n                this.fadeOutSong();\n            }, 1000);\n        } else {\n            console.log(\">>>>>>>   >>> \", this.props.deckName, \" FADED OUT_________\");\n            this.fadingOut = false;\n            this.waveform.setVolume(0);\n            this.waveform.pause();\n            this.props.finished();\n        }\n    }\n\n    fadeInSong() {\n        // console.log(\"*****\", this.props.deckName, \"fading in\", this.props.recommendedVolume);\n        this.fadingIn = true;\n        // console.log(this.props.recommendedVolume);\n        let newVol = lerp(this.waveform.getVolume(), this.props.recommendedVolume, Math.min((this.waveform.getVolume()) / 4), 0.05, this.props.deckName);\n        if (isFinite(newVol)) this.waveform.setVolume(newVol);\n        \n        if (this.waveform.getVolume() < this.props.recommendedVolume - 0.1) {\n            setTimeout(() => {\n                this.fadeInSong();\n            }, 1000);\n        } else {\n            console.log(\">>>>>>>  !!!  >>> \", this.props.deckName, \" FADED IN_________!!!!\");\n            this.fadingIn = false;\n            this.waveform.setVolume(this.props.recommendedVolume);\n        }\n    }\n\n    render() {\n        return (\n            <>\n                <div className={\"deck\"}>\n                    <img src={this.props.songImage.url} alt=\"\" />\n                    <div className={\"deck-content\"}>\n                        <div className={\"deck-text\"}>\n                            {this.props.songName !== \"\" && <h2>{this.props.songName}</h2>}\n                            {this.props.songName !== \"\" && <h3>{this.props.songArtist}</h3>}\n                        </div>\n                        <div className={\"deck-text\"}>\n                            <h4>{this.props.bpm} BPM</h4>\n                            {/* <h4>{this.props.bpm} BPM</h4> */}\n                        </div>\n                        <div id={`${this.props.waveformID}`} />\n                    </div>\n                    {/* <Knob size={70} numTicks={70} degrees={260} min={0} max={100} value={50} color={true} onChange={this.changeGain} /> */}\n                    {/* <Knob size={70} numTicks={70} degrees={260} min={1000} max={30000} value={15000} color={true} onChange={this.changeFilter} /> */}\n                </div>\n            </>\n        );\n    }\n}\n\nfunction lerp(start, end, amt, deckname) {\n    // console.log(deckname, \"lerped this:\", start, end, amt, \"to:\", (1 - amt) * start + amt * end);\n    return (1 - amt) * start + amt * end\n}\n\n","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Knob.js",[],"/Users/parssa/Desktop/repos/mixbot/src/api/keys.js",["134","135","136"],"const youtubeKey1 = \"AIzaSyC6F5gJnOX3mS2dl5-b_82PQ2ow7Xikuw8\"; // NotMixBot\n\nconst youtubeKey2 = \"AIzaSyCt7QrJ3-iInh6822WGi3Igo8J9gpH2WyA\"; // ThirdBot\n\nconst youtubeKey3 = \"AIzaSyBpT_RmX3P3wp_OMxiJT0SZIhkqFwMfVrA\"; // not set up yet\n\nconst youtubeKey4 = \"AIzaSyDgc98evXaE_C01NhK6ls2n7ZDkR - vg6sU\"; // backupPlan\n\n\nexport const currentKey = youtubeKey4;",["137","138"],"/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Queue.js",[],"/Users/parssa/Desktop/repos/mixbot/src/Mixbot.js",["139","140"],"import React, { useState } from 'react';\nimport TrackSelector from \"./TrackSelector\";\nimport TrackPlayer from \"./TrackPlayer\";\nimport QueueBox from \"./frontend_components/Queue\";\nimport Brain from \"./Brain\";\nimport axios from 'axios';\n\nlet tracklist = [];\nlet upcomingSongs = [];\nlet alreadyPlayed = [];\n\nconst baseURL = 'http://localhost:8080';\nconst addSongRefURL = baseURL + '/addSongRef'\n\n// --- Global Functions ---\nexport function trackAlreadyIn(trackName) {\n    // console.log(\"checking if track is already in....\", trackName);\n    for (const trackObj of tracklist) {\n        // console.log(trackObj.songName)\n        if (trackObj.songName === trackName)\n            return true;\n    }\n    return false;\n}\n\nexport function loadTrack() {\n    let nextSong = null;\n    if (upcomingSongs.length !== 0) {\n        nextSong = upcomingSongs[0].body;\n        alreadyPlayed.push(nextSong);\n        upcomingSongs.shift();\n    }\n    return nextSong;\n}\n\nexport function nextSongInQueue() {\n    return upcomingSongs[0] || null;\n}\n\nexport function tracklistSize() {\n    return tracklist.length;\n}\n\nexport const thoughtType = {\n    NEUTRAL: 1,\n    SUCCESS: 2,\n    FAILURE: 3,\n    MIX: 4\n}\n\nexport default function Mixbot() {\n    const [thoughts, setThoughts] = useState([]);\n\n    function newThought(input, type = thoughtType.NEUTRAL) {\n        // console.log(\"1. new thought added\", input);\n        let shouldShow = true;\n        if (thoughts.length > 0 && thoughts[thoughts.length - 1].body === input) {\n            shouldShow = false;\n        }\n        setThoughts([...thoughts, { id: \"THOUGHT-\" + thoughts.length, body: input, type: type, display: shouldShow }]);\n        // console.log(\"2. new thought added\", thoughts);\n    }\n\n    /**\n     * \n     * @param {*} songName: name of song\n     * @param {*} songArtists : array of artists of song\n     * @param {*} duration_ms: duration in ms \n     * @param {*} songURL: url to the temp reference link \n     * @param {*} analysis: raw spotify analysis \n     * @param {*} trackImage: img of album art \n     * @param {*} songID:  ID OF THE SPOTIFY SONG\n     * @param {*} videoID:  ID OF THE CORRESPONDING YT ID\n     * @param {boolean} fromDatabase: true if fetched yt id from database\n     */\n    async function addToQueue(songName, songArtists, duration_ms, songURL, analysis, trackImage, songID, videoID, fromDatabase) {\n\n        // TODO MAKE THIS ONLY HAPPEN IF NOT FOUND IN DATABASE\n        if (analysis !== \"NOTFOUND\") {\n            if (!fromDatabase) {\n                console.log(\"not in db yet, adding it...\");\n\n                let correctedArtists = [];\n                songArtists.forEach(artist => correctedArtists.push(artist.name));\n\n                let songRefEntry = {\n                    songID: songID, // spotify id\n                    videoID: videoID, // youtube videoID\n                    name: songName,\n                    artists: correctedArtists,\n                    duration: duration_ms,\n                }\n                addSongRefDB(songRefEntry);\n            } else {\n                // console.log(\"got it from db!\");\n            }\n          \n            // Add it to the DB // todo\n            // let databaseEntry = {\n            // songID: songID,\n            // songName: songName,\n            // analyzed: analyzedData,\n            // }\n\n            // addTrackAnalysisDB(databaseEntry);\n\n        }\n\n        const newSong = {\n            songName: songName,\n            songArtists: songArtists,\n            duration_ms: duration_ms,\n            songURL: songURL,\n            songAnalysis: analysis,\n            trackImage: trackImage\n        }\n        // console.log(\">>>(MIXBOT): NEW SONG IS:\", newSong);\n        // console.log(\">>>(MIXBOT): ANALYSIS:\", analysis);\n        let packageSong = { id: \"tracklist\" + tracklist.length, body: newSong }\n        // console.log(\">>>(MIXBOT): PACKAGED SONG:\", packageSong);\n        tracklist.push(packageSong);\n        // console.log(\">>>(MIXBOT): ADDED TO TRACKLIST:\", tracklist);\n        upcomingSongs.push(packageSong);\n        // console.log(\">>>(MIXBOT): ADDED TO UPCOMING SONGS:\", upcomingSongs);\n        const think = `Added ${songName} to the tracklist`;\n        // console.log(\">>>(MIXBOT): ABOUT TO THINK:\", think);\n        newThought(think, thoughtType.NEUTRAL);\n    }\n\n    function addTrackAnalysisDB(entry) {\n        axios.create({\n            baseURL: 'http://localhost:8080',\n            headers: {}\n        }).get('/addAnalysis', {\n            params: {\n                data: entry\n            },\n        })\n    }\n\n    function addSongRefDB(entry) {\n        axios.get(addSongRefURL, {\n            params: { data: entry }\n        });\n    }\n\n\n    return (\n        <>\n            <TrackPlayer newThought={newThought} />\n            <div className=\"mixbot-dropdowns\">\n                <Brain decisions={thoughts} />\n                {tracklist.length == 0 ? null : <QueueBox items={tracklist} />}\n            </div>\n            <TrackSelector addToQueue={addToQueue} />\n        </>\n    )\n}\n","/Users/parssa/Desktop/repos/mixbot/src/Brain.js",[],"/Users/parssa/Desktop/repos/mixbot/src/helper_classes/Analyzer.js",[],{"ruleId":"141","replacedBy":"142"},{"ruleId":"143","replacedBy":"144"},{"ruleId":"145","severity":1,"message":"146","line":1,"column":16,"nodeType":"147","messageId":"148","endLine":1,"endColumn":24},{"ruleId":"145","severity":1,"message":"149","line":1,"column":26,"nodeType":"147","messageId":"148","endLine":1,"endColumn":35},{"ruleId":"145","severity":1,"message":"150","line":5,"column":8,"nodeType":"147","messageId":"148","endLine":5,"endColumn":13},{"ruleId":"145","severity":1,"message":"151","line":14,"column":20,"nodeType":"147","messageId":"148","endLine":14,"endColumn":29},{"ruleId":"145","severity":1,"message":"152","line":15,"column":22,"nodeType":"147","messageId":"148","endLine":15,"endColumn":33},{"ruleId":"145","severity":1,"message":"153","line":1,"column":8,"nodeType":"147","messageId":"148","endLine":1,"endColumn":13},{"ruleId":"145","severity":1,"message":"154","line":4,"column":17,"nodeType":"147","messageId":"148","endLine":4,"endColumn":20},{"ruleId":"145","severity":1,"message":"155","line":4,"column":33,"nodeType":"147","messageId":"148","endLine":4,"endColumn":40},{"ruleId":"156","severity":1,"message":"157","line":114,"column":8,"nodeType":"158","endLine":114,"endColumn":23,"suggestions":"159"},{"ruleId":"156","severity":1,"message":"160","line":139,"column":8,"nodeType":"158","endLine":139,"endColumn":36,"suggestions":"161"},{"ruleId":"145","severity":1,"message":"162","line":1,"column":7,"nodeType":"147","messageId":"148","endLine":1,"endColumn":12},{"ruleId":"145","severity":1,"message":"163","line":4,"column":38,"nodeType":"147","messageId":"148","endLine":4,"endColumn":49},{"ruleId":"156","severity":1,"message":"164","line":39,"column":5,"nodeType":"147","endLine":39,"endColumn":14,"suggestions":"165"},{"ruleId":"166","severity":1,"message":"167","line":50,"column":27,"nodeType":"168","messageId":"169","endLine":50,"endColumn":29},{"ruleId":"166","severity":1,"message":"167","line":50,"column":47,"nodeType":"168","messageId":"169","endLine":50,"endColumn":49},{"ruleId":"166","severity":1,"message":"167","line":53,"column":34,"nodeType":"168","messageId":"169","endLine":53,"endColumn":36},{"ruleId":"166","severity":1,"message":"167","line":53,"column":54,"nodeType":"168","messageId":"169","endLine":53,"endColumn":56},{"ruleId":"141","replacedBy":"170"},{"ruleId":"143","replacedBy":"171"},{"ruleId":"145","severity":1,"message":"146","line":1,"column":16,"nodeType":"147","messageId":"148","endLine":1,"endColumn":24},{"ruleId":"145","severity":1,"message":"172","line":9,"column":12,"nodeType":"147","messageId":"148","endLine":9,"endColumn":19},{"ruleId":"156","severity":1,"message":"173","line":50,"column":8,"nodeType":"158","endLine":50,"endColumn":13,"suggestions":"174"},{"ruleId":"156","severity":1,"message":"175","line":66,"column":8,"nodeType":"158","endLine":66,"endColumn":19,"suggestions":"176"},{"ruleId":"141","replacedBy":"177"},{"ruleId":"143","replacedBy":"178"},{"ruleId":"145","severity":1,"message":"179","line":2,"column":8,"nodeType":"147","messageId":"148","endLine":2,"endColumn":12},{"ruleId":"166","severity":1,"message":"180","line":182,"column":93,"nodeType":"168","messageId":"169","endLine":182,"endColumn":95},{"ruleId":"181","severity":1,"message":"182","line":334,"column":13,"nodeType":"183","endLine":334,"endColumn":37},{"ruleId":"181","severity":1,"message":"182","line":335,"column":13,"nodeType":"183","endLine":335,"endColumn":45},{"ruleId":"181","severity":1,"message":"182","line":338,"column":13,"nodeType":"183","endLine":338,"endColumn":37},{"ruleId":"181","severity":1,"message":"182","line":339,"column":13,"nodeType":"183","endLine":339,"endColumn":46},{"ruleId":"181","severity":1,"message":"182","line":341,"column":13,"nodeType":"183","endLine":341,"endColumn":37},{"ruleId":"181","severity":1,"message":"182","line":342,"column":13,"nodeType":"183","endLine":342,"endColumn":45},{"ruleId":"181","severity":1,"message":"182","line":343,"column":13,"nodeType":"183","endLine":343,"endColumn":37},{"ruleId":"181","severity":1,"message":"182","line":344,"column":13,"nodeType":"183","endLine":344,"endColumn":46},{"ruleId":"181","severity":1,"message":"182","line":367,"column":9,"nodeType":"183","endLine":367,"endColumn":41},{"ruleId":"145","severity":1,"message":"184","line":1,"column":7,"nodeType":"147","messageId":"148","endLine":1,"endColumn":18},{"ruleId":"145","severity":1,"message":"185","line":3,"column":7,"nodeType":"147","messageId":"148","endLine":3,"endColumn":18},{"ruleId":"145","severity":1,"message":"186","line":5,"column":7,"nodeType":"147","messageId":"148","endLine":5,"endColumn":18},{"ruleId":"141","replacedBy":"187"},{"ruleId":"143","replacedBy":"188"},{"ruleId":"145","severity":1,"message":"189","line":130,"column":14,"nodeType":"147","messageId":"148","endLine":130,"endColumn":32},{"ruleId":"166","severity":1,"message":"167","line":153,"column":35,"nodeType":"168","messageId":"169","endLine":153,"endColumn":37},"no-native-reassign",["190"],"no-negated-in-lhs",["191"],"no-unused-vars","'useState' is defined but never used.","Identifier","unusedVar","'useEffect' is defined but never used.","'axios' is defined but never used.","'setGenres' is assigned a value but never used.","'setPlaylist' is assigned a value but never used.","'React' is defined but never used.","'end' is defined but never used.","'pattern' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'videoIDtoMP3'. Either include it or remove the dependency array.","ArrayExpression",["192"],"React Hook useEffect has missing dependencies: 'checkDatabase', 'createSearchQuery', and 'getYoutubeVideo'. Either include them or remove the dependency array.",["193"],"'cred1' is assigned a value but never used.","'thoughtType' is defined but never used.","React Hook useEffect contains a call to 'setClock'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [clock] as a second argument to the useEffect Hook.",["194"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected",["190"],["191"],"'playing' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'volume'. Either include it or remove the dependency array. You can also do a functional update 'setVolume(v => ...)' if you only need 'volume' in the 'setVolume' call.",["195"],"React Hook useEffect has a missing dependency: 'handlePlayPause'. Either include it or remove the dependency array.",["196"],["190"],["191"],"'Knob' is defined but never used.","Expected '!==' and instead saw '!='.","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","'youtubeKey1' is assigned a value but never used.","'youtubeKey2' is assigned a value but never used.","'youtubeKey3' is assigned a value but never used.",["190"],["191"],"'addTrackAnalysisDB' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"197","fix":"198"},{"desc":"199","fix":"200"},{"desc":"201","fix":"202"},{"desc":"203","fix":"204"},{"desc":"205","fix":"206"},"Update the dependencies array to be: [chosenVideoID, videoIDtoMP3]",{"range":"207","text":"208"},"Update the dependencies array to be: [name, artists, duration_ms, checkDatabase, createSearchQuery, getYoutubeVideo]",{"range":"209","text":"210"},"Add dependencies array: [clock]",{"range":"211","text":"212"},"Update the dependencies array to be: [url, volume]",{"range":"213","text":"214"},"Update the dependencies array to be: [handlePlayPause, isPlaying]",{"range":"215","text":"216"},[4296,4311],"[chosenVideoID, videoIDtoMP3]",[5155,5183],"[name, artists, duration_ms, checkDatabase, createSearchQuery, getYoutubeVideo]",[1369,1369],", [clock]",[1849,1854],"[url, volume]",[2436,2447],"[handlePlayPause, isPlaying]"]