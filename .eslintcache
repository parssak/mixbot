[{"/Users/parssa/Desktop/repos/mixbot/src/index.js":"1","/Users/parssa/Desktop/repos/mixbot/src/App.js":"2","/Users/parssa/Desktop/repos/mixbot/src/reportWebVitals.js":"3","/Users/parssa/Desktop/repos/mixbot/src/TrackSelector.js":"4","/Users/parssa/Desktop/repos/mixbot/src/TrackFinder.js":"5","/Users/parssa/Desktop/repos/mixbot/src/Credentials.js":"6","/Users/parssa/Desktop/repos/mixbot/src/TrackPlayer.js":"7","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Detail.js":"8","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Listbox.js":"9","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Dropdown.js":"10","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Waveform.js":"11","/Users/parssa/Desktop/repos/mixbot/src/api/youtubeVideoContent.js":"12","/Users/parssa/Desktop/repos/mixbot/src/api/youtube.js":"13","/Users/parssa/Desktop/repos/mixbot/src/Deck.js":"14","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Knob.js":"15","/Users/parssa/Desktop/repos/mixbot/src/api/keys.js":"16","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Queue.js":"17","/Users/parssa/Desktop/repos/mixbot/src/Mixbot.js":"18","/Users/parssa/Desktop/repos/mixbot/src/Brain.js":"19","/Users/parssa/Desktop/repos/mixbot/src/helper_classes/Analyzer.js":"20"},{"size":500,"mtime":1609255907946,"results":"21","hashOfConfig":"22"},{"size":968,"mtime":1610343348487,"results":"23","hashOfConfig":"22"},{"size":362,"mtime":1609255907947,"results":"24","hashOfConfig":"22"},{"size":6739,"mtime":1610390742809,"results":"25","hashOfConfig":"22"},{"size":5572,"mtime":1610390597305,"results":"26","hashOfConfig":"22"},{"size":315,"mtime":1610336027864,"results":"27","hashOfConfig":"22"},{"size":9464,"mtime":1610390035777,"results":"28","hashOfConfig":"22"},{"size":570,"mtime":1609255907945,"results":"29","hashOfConfig":"22"},{"size":814,"mtime":1610305380930,"results":"30","hashOfConfig":"22"},{"size":550,"mtime":1609255907945,"results":"31","hashOfConfig":"22"},{"size":3782,"mtime":1609255907946,"results":"32","hashOfConfig":"22"},{"size":767,"mtime":1610248130668,"results":"33","hashOfConfig":"22"},{"size":535,"mtime":1610299742890,"results":"34","hashOfConfig":"22"},{"size":17168,"mtime":1610391073685,"results":"35","hashOfConfig":"22"},{"size":4780,"mtime":1609255907945,"results":"36","hashOfConfig":"22"},{"size":354,"mtime":1610328014835,"results":"37","hashOfConfig":"22"},{"size":608,"mtime":1610376480379,"results":"38","hashOfConfig":"22"},{"size":4991,"mtime":1610389706831,"results":"39","hashOfConfig":"22"},{"size":1120,"mtime":1610376717223,"results":"40","hashOfConfig":"22"},{"size":8246,"mtime":1610389957213,"results":"41","hashOfConfig":"22"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"11p3aqi",{"filePath":"45","messages":"46","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"44"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"44"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"44"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"44"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"44"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69","usedDeprecatedRules":"64"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"72","usedDeprecatedRules":"73"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"84","usedDeprecatedRules":"85"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"90","usedDeprecatedRules":"44"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"95","usedDeprecatedRules":"44"},"/Users/parssa/Desktop/repos/mixbot/src/index.js",[],["96","97"],"/Users/parssa/Desktop/repos/mixbot/src/App.js",["98","99","100"],"import React, {useState, useEffect} from 'react';\nimport './css_files/App.css';\nimport Mixbot from './Mixbot';\n\nimport axios from 'axios';\n\nfunction App() {\n\n    // function makeRequest() {\n    //     console.log(\"boutta make request\");\n    //     axios.create({\n    //         baseURL: 'http://localhost:8080',\n    //         headers: {}\n    //     }).get('/addEntry', {\n    //         params: {\n    //             songEntry: {\n    //                 name: \"AHA AHA AHA\"\n    //             }\n    //         },\n    //     })\n    // }\n\n    return(\n        <div className={\"body\"}>\n            <div className={\"title\"}>\n                <h1>MIXBOT</h1>\n                <div className={\"credits\"}>\n                    {/* <button onClick={() => { makeRequest() }}>Make request</button> */}\n                    <h3>An Open Source project by Parssa Kyanzadeh</h3> \n                 </div>\n            </div>\n            <Mixbot/>\n        </div>\n    );\n}\nexport default App;\n","/Users/parssa/Desktop/repos/mixbot/src/reportWebVitals.js",[],"/Users/parssa/Desktop/repos/mixbot/src/TrackSelector.js",["101","102"],"import React, { useState, useEffect } from 'react';\nimport { Credentials } from './Credentials';\nimport axios from 'axios';\nimport Listbox from \"./frontend_components/Listbox\";\nimport { Analyzer } from './helper_classes/Analyzer';\nimport TrackFinder from \"./TrackFinder\";\nimport { trackAlreadyIn, tracklistSize } from \"./Mixbot\";\n\nconst euroHouseID = \"2818tC1Ba59cftJJqjWKZi\";\n\nfunction TrackSelector({ addToQueue }) {\n    const spotify = Credentials();\n    const [token, setToken] = useState('');\n    const [genres, setGenres] = useState({ selectedGenre: '', listOfGenresFromAPI: [] });\n    const [playlist, setPlaylist] = useState({ selectedPlaylist: euroHouseID, listOfPlaylistFromAPI: [] });\n    const [tracks, setTracks] = useState({ selectedTrack: '', listOfTracksFromAPI: [] });\n    const [trackDetail, setTrackDetail] = useState(null);\n\n    useEffect(() => {\n        axios('https://accounts.spotify.com/api/token', {\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                'Authorization': 'Basic ' + btoa(spotify.ClientId + ':' + spotify.ClientSecret)\n            },\n            data: 'grant_type=client_credentials',\n            method: 'POST'\n        })\n            .then(tokenResponse => {\n                setToken(tokenResponse.data.access_token);\n                console.log(\"got ma token\");\n                // axios('https://api.spotify.com/v1/browse/categories', {\n                //     method: 'GET',\n                //     headers: { 'Authorization' : 'Bearer ' + tokenResponse.data.access_token}\n                // })\n                //     .then (genreResponse => {\n                //         console.log(genreResponse)\n                //         setGenres({\n                //             selectedGenre: genres.selectedGenre,\n                //             listOfGenresFromAPI: genreResponse.data.categories.items\n                //         })\n                //     });\n\n            });\n\n    }, [genres.selectedGenre, spotify.ClientId, spotify.ClientSecret]);\n\n    function genreChanged(val) {\n        setGenres({\n            selectedGenre: val,\n            listOfGenresFromAPI: genres.listOfGenresFromAPI\n        });\n\n        axios(`https://api.spotify.com/v1/browse/categories/${val}/playlists?limit=30`, {\n            method: 'GET',\n            headers: { 'Authorization': 'Bearer ' + token }\n        }).then(playlistResponse => {\n            setPlaylist({\n                selectedPlaylist: playlist.selectedPlaylist,\n                listOfPlaylistFromAPI: playlistResponse.data.playlists.items\n            })\n        });\n    }\n\n    function playlistChanged(val) {\n        setPlaylist({\n            selectedPlaylist: val,\n            listOfPlaylistFromAPI: playlist.listOfPlaylistFromAPI\n        });\n    }\n\n    function playlistSearchClicked(e) {\n        e.preventDefault();\n        console.log(\"selected playlist was\" + playlist.selectedPlaylist);\n        axios(`https://api.spotify.com/v1/playlists/${playlist.selectedPlaylist}/tracks?limit=40`, {\n            method: 'GET',\n            headers: {\n                'Authorization': 'Bearer ' + token\n            }\n        }).then(tracksResponse => {\n            setTracks({\n                selectedTrack: tracks.selectedTrack,\n                listOfTracksFromAPI: tracksResponse.data.items\n            })\n        });\n    }\n\n    function selectTrack(val) {\n        const currentTracks = [...tracks.listOfTracksFromAPI];\n        const trackInfo = currentTracks.filter(t => t.track.id === val);\n        if (!trackAlreadyIn(trackInfo[0].track.name)) {\n            console.log(\">>>\", trackInfo[0].track);\n            setTrackDetail(trackInfo[0].track);\n        } else {\n            console.log(\"track is already in the queue\");\n        }\n    }\n\n    async function addSongToTracklist(songName, songArtists, duration, songURL, trackID, trackImage, youtubeVideoID, fromDatabase) {\n        if (!trackAlreadyIn(songName)) {\n            console.log(\"adding: \" + songName + \"with id \" + trackID);\n            await getAudioAnalysis(trackID, songName, songArtists, duration, songURL, trackImage, youtubeVideoID, fromDatabase);\n        } else {\n            console.log(\"track is already in the queue\");\n            setTrackDetail(null);\n        }\n    }\n\n    async function checkForSongAnalysis(songID) {\n        console.log(\"boutta check songAnalysis\");\n        let result = null;\n        if (songID) {\n            result = await axios.get('http://localhost:8080/checkEntryAnalysis', {\n                params:\n                {\n                    data: songID\n                }\n            });\n        }\n        return result.data;\n    }\n\n    const getAudioAnalysis = async (id, songName, songArtists, duration, songURL, trackImage, youtubeVideoID, fromDatabase) => {\n        console.log(\"song id is \" + id);\n\n        // 1) Check if DB already contains songAnalysis\n        let analysisInDB = await checkForSongAnalysis(id);\n        \n        console.log(\">>>> !> >!> >!>:\", analysisInDB);\n        console.log(\"analysis in db??:\", analysisInDB.data);\n\n        // 2) If song does not contain\n        if (!analysisInDB.data) {\n            console.log(\"IT ISNT MUCHHHHHHHHHHH\");\n            let rawAnalysis = await axios(`https://api.spotify.com/v1/audio-analysis/${id}`, {\n                method: 'GET',\n                headers: {\n                    'Authorization': 'Bearer ' + token\n                }\n            });\n\n            // Clean up the spotify data\n            let songData = rawAnalysis.data;\n            let analyzer = new Analyzer();\n            let analyzedData = analyzer.analyzeSong(songData);\n            analysisInDB = analyzedData;\n        }\n        console.log(\">>>>>>>>>>>>>>>>..... analysis in db sending out!\", analysisInDB);\n        addToQueue(songName, songArtists, duration, songURL, analysisInDB, trackImage, id, youtubeVideoID, fromDatabase);\n        setTrackDetail(null);\n    }\n\n    return (\n        <div style={{ marginTop: \"15em\" }}>\n            <form onSubmit={playlistSearchClicked}>\n                {tracklistSize() === 0 && <button type='submit' className=\"begin-mix\">BEGIN MIX</button>}\n                <div style={{ marginTop: \"4em\" }}>\n                    <Listbox items={tracks.listOfTracksFromAPI} clicked={selectTrack} />\n                    {trackDetail && <TrackFinder name={trackDetail.name}\n                        artists={trackDetail.artists}\n                        duration_ms={trackDetail.duration_ms}\n                        trackID={trackDetail.id}\n                        trackImage={trackDetail.album.images[1]}\n                        foundSong={addSongToTracklist} />}\n                </div>\n            </form>\n        </div>\n    );\n}\n\nexport default TrackSelector;\n","/Users/parssa/Desktop/repos/mixbot/src/TrackFinder.js",["103","104","105","106","107"],"import React, { useEffect, useState } from 'react';\nimport youtubeApi from './api/youtube'\nimport videoDetailFinder from './api/youtubeVideoContent'\nimport { parse, end, toSeconds, pattern } from 'iso8601-duration';\nimport axios from 'axios';\n\nconst baseURL = 'http://localhost:8080';\n/**\n * This class handles finding a track based on song name, artists, and duration\n * and calls the foundSong prop when a song has been found.\n *\n * @param name: Name of the Song\n * @param artists: An array of artist objects\n * @param duration_ms: The duration of the song in milliseconds\n * @param foundSong: A prop that gets called when song has been found\n * @param trackID: id of the spotify song\n */\nlet lastChosenID = \"\";\nlet fromDatabase = false;\nexport default function TrackFinder({ name, artists, duration_ms, foundSong, trackID, trackImage }) {\n\n    // const [songName, setSongName] = useState(name);\n    // const [songArtists, setSongArtists] = useState(artists);\n    // const [duration, setDuration] = useState(duration_ms);\n    const [chosenVideoID, setChosenVideoID] = useState(\"\");\n\n    function createSearchQuery() {\n        let artistNames = [];\n        artists.forEach(e => {\n            const thisName = e.name;\n            if (thisName) {\n                artistNames.push(thisName)\n            }\n        });\n        let searchQuery = name + \" by \" + artistNames[0];\n        return searchQuery;\n    }\n\n\n    async function videosSearch(search) {\n        const response = await youtubeApi.get(\"/youtubeSearch\", { // TODO CHANGE THIS TO SERVER\n            params: {\n                q: search\n            }\n        })\n        return response;\n    }\n\n    async function videoDetail(videoID) {\n        const response = await videoDetailFinder.get(\"/youtubeDetail\", {\n            params: {\n                id: videoID\n            }\n        })\n        return response;\n    }\n\n    /**\n     * Searches YouTube for song using search query, breaks when found is song\n     * @param searchQuery\n     * @returns {Promise<void>}\n     */\n    async function getYoutubeVideo(searchQuery) {\n        videosSearch(searchQuery).then(async e => {\n            const videoList = e.data.items;                                                     // a list of videos                 \n            for (let video = 0; video < videoList.length; video++) {                            // for each video in the videoList...\n                console.log(\">>>>>>>>\", chosenVideoID, \"<<<<<<<<<\");\n                const thisDetails = await videoDetail(videoList[video].id.videoId);             // Get details...\n                const thisDur = toMilli(thisDetails.data.items[0].contentDetails.duration);     // Get duration from details...\n                if (Math.abs(duration_ms - thisDur) <= 1000) {                                     // If the duration is what we're looking for...\n                    console.log(\">>>>>>>> BINGO! <<<<<<<<<\");\n                    setChosenVideoID(videoList[video].id.videoId); // TODO FIX THIS OMG THIS IS AN ABSOLUTE ABUSE OF STATE.\n                    break;\n                }\n            }\n        })\n    }\n\n    /**\n     * Helper function for converting ISO8 8601 time to milliseconds\n     * @param ISO: ISO time\n     * @returns {the ISO time in milliseconds}\n     */\n    function toMilli(ISO) {\n        return toSeconds(parse(ISO)) * 1000;\n    }\n\n    /**\n     * This effect triggers when the chosenVideoID is\n     * found, and then get the URL for mp3 download\n     *\n     * Since this effect gets called over once for the\n     * same video being found sometimes, it will not\n     * convert the video to mp3 if it has already been\n     * called once for this current song\n     * >> “ \"lastChosenID === \"\" ”\n     */\n    useEffect(() => {\n\n        if (chosenVideoID && lastChosenID === \"\") {\n            lastChosenID = chosenVideoID;\n            videoIDtoMP3(chosenVideoID);\n        }\n\n    }, [chosenVideoID])\n\n    useEffect(() => {          // TODO FIX WHEN AVAILABLE\n        // setSongArtists(artists);\n        // setSongName(name);\n        // setDuration(duration_ms);\n        console.log(\"use effect for checking entereed\");\n        async function findYoutubeID() {\n            console.log(\"entered async bit\");\n            const result = await checkDatabase();\n            lastChosenID = \"\";\n            if (result === \"\") {\n                console.log(\"Going to find the song\");\n                fromDatabase = false;\n                const search = createSearchQuery();\n                await getYoutubeVideo(search);\n            } else {\n                console.log(\"Got it from the DB!\");\n                fromDatabase = true;\n                setChosenVideoID(result.videoID); \n            }\n        }\n\n        findYoutubeID();\n\n    }, [name, artists, duration_ms]);\n\n    async function checkDatabase() { // TODO MOVE THIS INTO IT'S OWN CLASS\n        let result = null;\n        if (trackID) {\n            result = await axios.get(baseURL + '/checkForEntry', {\n                params:\n                {\n                    data: trackID\n                }\n            });\n        }\n        return result.data;\n    }\n\n    async function videoIDtoMP3(videoID) { \n        videoDetailFinder.get('/youtubeMp3', {\n            params: {\n                id: videoID\n            }\n        }).then(response => {\n            let audioFormats = response.data;\n            foundSong(name, artists, duration_ms, audioFormats[0].url, trackID, trackImage, videoID, fromDatabase); // ! ADD FROMDATABASE\n            setChosenVideoID(\"\");\n        });\n    }\n\n    return null;\n}","/Users/parssa/Desktop/repos/mixbot/src/Credentials.js",["108"],"const cred1 = {\n    ClientId: '2f960da39c8b42d9a8dc394d02b97db0',\n    ClientSecret: '860fabcadd034f1d9368e7ca7791de73'\n}\n\n\nconst cred2 = {\n    ClientId: '75cbbf8c1ff14b9abe3cbfe6924fb5f0',\n    ClientSecret: 'da55e142b302460cab9b737153b93eb4'\n}\n\n\nfunction Credentials() {\n    return cred2;\n}\n\nexport { Credentials };","/Users/parssa/Desktop/repos/mixbot/src/TrackPlayer.js",["109","110","111","112","113","114"],"import React, { useEffect, useState } from 'react';\nimport Deck from \"./Deck\";\nimport './css_files/Queue.scss';\nimport { loadTrack, nextSongInQueue, thoughtType } from \"./Mixbot\";\n\n// let deck1playtime = NaN;\n// let deck2playtime = NaN;\n\nlet deck1startTime = 0;\nlet deck2startTime = 0;\n\nlet lastTrackSet = 0;\nlet mainTrack = 0;\n\nlet deck1lastBar = 0;\nlet deck2lastBar = 0;\n\nexport default function TrackPlayer({newThought}) {\n    const [clock, setClock] = useState();\n\n    const [deck1Song, setDeck1Song] = useState('');\n    const [deck2Song, setDeck2Song] = useState('');\n\n    const [deck1BPM, setDeck1BPM] = useState(0);\n    const [deck2BPM, setDeck2BPM] = useState(0);\n\n    const [deck1playback, setDeck1playback] = useState(1);\n    const [deck2playback, setDeck2playback] = useState(1);\n\n    const [deck1prepared, setDeck1prepared] = useState(false);\n    const [deck2prepared, setDeck2prepared] = useState(false);\n\n    const [deck1Playing, setDeck1Playing] = useState(false);\n    const [deck2Playing, setDeck2Playing] = useState(false);\n\n    const [deck1offset, setDeck1offset] = useState(0);\n    const [deck2offset, setDeck2offset] = useState(0);\n\n    useEffect(() => {\n        console.log(\"-----------------player did update!-----------------\");\n        if (!clock) {\n            let newClock = new AudioContext();\n            setClock(newClock);\n        } \n    })\n\n    useEffect(() => {\n        if (nextSongInQueue() !== null) {\n            console.log(\">>> theres a song in the queue!\", nextSongInQueue());\n            if ((deck1BPM == 0) && (deck1Song == '')) {\n                console.log(\">> putting it in track a\");\n                loadTrackA();\n            } else if ((deck2BPM == 0) && (deck2Song == '')) {\n                console.log(\">> putting it in track b\");\n                loadTrackB();\n            }\n        }\n    })\n\n    function loadTrackA() {\n        let newSong = loadTrack();\n        setDeck1prepared(false);\n        setDeck1Playing(false);\n        if (newSong !== null) {\n            console.log(\"new\");\n            console.log(newSong);\n            setDeck1BPM(Math.round(newSong.songAnalysis.tempo)) // terribly sus\n            if (deck2Song === '') {\n                setDeck1playback(1);\n            } else {\n                if (deck2BPM !== 0) {\n                    let ratio = (deck2BPM / newSong.songAnalysis.tempo).toPrecision(5);\n                    setDeck1playback(ratio);\n                } else {\n                    setDeck1playback(1);\n                }\n            }\n            console.log(\"> , --------------------------->> \", newSong);\n            let think = \"Put \" + newSong.songName + \" on Deck A\";\n            newThought(think);\n            setDeck1Song(newSong);\n        }\n        else {\n            console.log(\"new song was null\");\n        }\n    }\n\n    function loadTrackB() {\n        let newSong = loadTrack();\n        setDeck2prepared(false);\n        setDeck2Playing(false);\n        if (newSong !== null) {\n            setDeck2BPM(Math.round(newSong.songAnalysis.tempo)) // terribly sus\n            console.log(\">>>>>            here comes the next song\", newSong);\n            if (deck1Song === '') {\n                setDeck2playback(1);\n            } else {\n                if (deck1BPM !== 0) {\n                    let ratio = (deck1BPM / Math.round(newSong.songAnalysis.tempo)).toPrecision(5);\n                    setDeck2playback(ratio);\n                } else {\n                    setDeck2playback(1);\n                }\n            }\n            let think = \"Put \" + newSong.songName + \" on Deck B\";\n            newThought(think);\n            setDeck2Song(newSong)\n        } else {\n            console.log(\"new song was null\");\n        }\n    }\n\n    function deckOneReady() {\n        if (!deck1prepared) {\n            setDeck1prepared(true);\n            console.log(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SETTING D1READY\");\n            if (!deck2Playing) {\n                console.log(\"telling deck 1 to play\");\n                setDeck1Playing(true);\n            }\n        }\n    }\n\n    function deckTwoReady() {\n        if (!deck2prepared) {\n            setDeck2prepared(true);\n            console.log(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SETTING D2READY\");\n            if (!deck1Playing) {\n                console.log(\"telling deck 2 to play\");\n                setDeck2Playing(true);\n            }\n        }\n    }\n\n    // function playDeck2SongScheduled(timeoutValue) {\n    //     console.log(\"setting timeout for:\", timeoutValue);\n    //     setTimeout(function () {\n    //         console.log(clock.currentTime, deck2playtime);\n    //         console.log(\"checkin time bois\", deck2playtime - clock.currentTime);\n    //         if (deck2playtime - clock.currentTime <= 0) {\n    //             deck2startTime = deck2playtime - clock.currentTime;\n    //             setDeck2Playing(true);\n    //         } else {\n    //             console.log(deck2playtime - clock.currentTime);\n    //             if ((deck2playtime - clock.currentTime) <= 0.5) {\n    //                 console.log(\"case a \");\n    //                 playDeck2SongScheduled(500);\n    //             } else {\n    //                 console.log(\"case b \");\n    //                 playDeck2SongScheduled((deck2playtime - clock.currentTime) / 2);\n    //             }\n    //         }\n    //     }, timeoutValue)\n    // }\n\n    function playTrackTwo() {\n        if (deck2prepared) {\n            console.log(\"+++ deck TWO is prepared, gonna play it!\");\n            setDeck2Playing(true);\n            setDeck2prepared(false);\n            if (lastTrackSet === 0) {\n                lastTrackSet = 2;\n                mainTrack = 1;\n            }\n        }\n    }\n\n    function playTrackOne() {\n        if (deck1prepared) {\n            console.log(\"+++ deck ONE is prepared, gonna play it!\");\n            setDeck1Playing(true);\n            setDeck1prepared(false);\n            if (lastTrackSet === 0) {\n                lastTrackSet = 1;\n                mainTrack = 1;\n            }\n\n        }\n    }\n\n    function hitBarD1() {\n        deck1lastBar = clock.currentTime;\n        if (deck2Playing) {\n            console.log(\"DECK1\", deck1offset);\n            setDeck1offset(deck2lastBar - deck1lastBar);\n        }\n    }\n\n    function hitBarD2() {\n        deck2lastBar = clock.currentTime;\n        if (deck1Playing) {\n            console.log(\"DECK2\", deck2offset);\n            setDeck2offset(deck1lastBar - deck2lastBar);\n        }\n    }\n\n    function changeTrackA() {\n        mainTrack = 2;\n        setDeck2playback(1);\n        loadTrackA();\n    }\n\n    function changeTrackB() {\n        mainTrack = 1;\n        setDeck1playback(1);\n        loadTrackB();\n    }\n\n    return (\n        <>\n            <div className={\"djboard\"}>\n                <div className={\"boardpanel\"} style={deck1Playing ? { boxShadow: \"0 3px 100px rgba(255, 99, 71, 0.3)\" } : { boxShadow: \"0 0 0 rgba(255, 99, 71, 0.3)\" }}>\n                    <h3>DECK A</h3>\n                    {deck1Song !== '' && <Deck\n                        thisSong={deck1Song.songURL}\n                        songName={deck1Song.songName}\n                        songArtist={deck1Song.songArtists[0].name}\n                        songImage={deck1Song.trackImage}\n                        songAnalysis={deck1Song.songAnalysis}\n                        playbackRate={deck1playback}\n                        prepared={deckOneReady}\n                        play={deck1Playing}\n                        startTime={deck1startTime}\n                        playOtherTrack={playTrackTwo}\n                        hitBar={hitBarD1}\n                        offset={deck1offset}\n                        deckName={\"Deck A\"}\n                        finished={changeTrackA}\n                        recommendedVolume={1}\n                        shouldSync={mainTrack !== 1}\n                        otherReady={deckTwoReady}\n                        waveformID={\"waveformA\"}\n                        bpm={deck1BPM}\n                        newThought={newThought}\n                    />\n                    }\n\n                </div>\n                <div className={\"boardpanel\"} style={deck2Playing ? { boxShadow: \"0 3px 100px rgba(255, 99, 71, 0.3)\" } : { boxShadow: \"0 0 0 rgba(255, 99, 71, 0.3)\" }}>\n                    <h3 style={{ textAlign: 'right' }}>DECK B</h3>\n                    {deck2Song !== '' && <Deck\n                        thisSong={deck2Song.songURL}\n                        songName={deck2Song.songName}\n                        songArtist={deck2Song.songArtists[0].name}\n                        songImage={deck2Song.trackImage}\n                        songAnalysis={deck2Song.songAnalysis}\n                        playbackRate={deck2playback}\n                        prepared={deckTwoReady}\n                        play={deck2Playing}\n                        startTime={deck2startTime}\n                        playOtherTrack={playTrackOne}\n                        hitBar={hitBarD2}\n                        offset={deck2offset}\n                        deckName={\"Deck B\"}\n                        finished={changeTrackB}\n                        recommendedVolume={1}\n                        shouldSync={mainTrack !== 2}\n                        otherReady={deckOneReady}\n                        waveformID={\"waveformB\"}\n                        bpm={deck2BPM}\n                        newThought={newThought}\n                    />}\n                </div>\n            </div>\n        </>\n    );\n}","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Detail.js",[],["115","116"],"/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Listbox.js",[],"/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Dropdown.js",["117"],"import React, {useState} from 'react';\n\nconst Dropdown = props => {\n\n    const dropdownChanged = e => {\n        props.changed(e.target.value);\n\n    }\n\n    return (\n        <div className=\"dropdown\">\n            <label>{props.label}</label>\n            <select value={props.selectedValue} onChange={dropdownChanged}>\n                <option key={0}>Select...</option>\n                {props.options.map((item, idx) => <option key={idx + 1} value={item.id}>{item.name}</option>)}\n            </select>\n        </div>\n    );\n}\n\nexport default Dropdown;\n","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Waveform.js",["118","119","120"],"import React, { useEffect, useRef, useState } from \"react\";\nimport WaveSurfer from 'wavesurfer.js';\n\n//https://codesandbox.io/s/audio-player-with-wavesurferjs-react-bd499?from-embed=&file=/src/Waveform.js:0-60\n\nexport default function Waveform({ url, onPositionChange, isPlaying, audioCtx, lowpassNum }) {\n    const waveformRef = useRef(null);\n    const wavesurfer = useRef(null);\n    const [playing, setPlay] = useState(false);\n    const [volume, setVolume] = useState(0.5);\n    const formWaveSurferOptions = ref => ({\n        container: ref,\n        waveColor: \"#beb9b9\",\n        progressColor: \"#9a68c9\",\n        cursorColor: \"#dac4f0\",\n        hideScrollbar: true,\n        responsive: true,\n        partialRender: true,\n        normalize: true,\n        height:200\n    });\n\n    // create new WaveSurfer instance\n    // On component mount and when url changes\n    useEffect(() => {\n        setPlay(false);\n\n        const options = formWaveSurferOptions(waveformRef.current);\n        wavesurfer.current = WaveSurfer.create(options);\n        wavesurfer.current.load(url.src);\n        wavesurfer.current.on(\"ready\", function() {\n            // https://wavesurfer-js.org/docs/methods.html\n            // wavesurfer.current.play();\n            // setPlay(true);\n\n            // make sure object still available when file loaded\n            if (wavesurfer.current) {\n                wavesurfer.current.setVolume(volume);\n                setVolume(volume);\n            }\n            let lowpass = wavesurfer.backend.ac.createBiquadFilter();\n            lowpass.type = \"lowpass\";\n            lowpass.frequency.value = 10;\n            wavesurfer.current.backend.setFilter(lowpass);\n        });\n\n        // Removes events, elements and disconnects Web Audio nodes.\n        // when component unmount\n        return () => wavesurfer.current.destroy();\n    }, [url]);\n\n    useEffect(() => {\n        console.log(\"!!!\")\n        handlePlayPause();\n        console.log(wavesurfer.current.getFilters());\n        // if (isPlaying !== playing) {\n        //     handlePlayPause();\n        // }\n        // wavesurfer.current.on('audioprocess', function () {\n        //     // $('.waveform__counter').text( formatTime(wavesurfer.getCurrentTime()) );\n        //     // console.log(wavesurfer.current.getCurrentTime());\n        //     // console.log(\"--\")\n        //     onPositionChange(wavesurfer.current.getCurrentTime());\n        //\n        // });\n    }, [isPlaying]);\n\n    useEffect( () => {\n        console.log(\"lowpass\", lowpassNum);\n\n    }, [lowpassNum])\n\n\n    const handlePlayPause = () => {\n        console.log(\"switching this\");\n        setPlay(isPlaying);\n        wavesurfer.current.playPause();\n    };\n\n    // const onVolumeChange = e => {\n    //     const { target } = e;\n    //     const newVolume = +target.value;\n    //\n    //     if (newVolume) {\n    //         setVolume(newVolume);\n    //         wavesurfer.current.setVolume(newVolume || 1);\n    //     }\n    // };\n\n    return (\n        <div className={\"waveform-comp\"}>\n            <div id=\"waveform\" ref={waveformRef} />\n            <div className=\"controls\">\n                {/*<button onClick={handlePlayPause}>{!playing ? \"Play\" : \"Pause\"}</button>*/}\n                {/*<input*/}\n                {/*    type=\"range\"*/}\n                {/*    id=\"volume\"*/}\n                {/*    name=\"volume\"*/}\n                {/*    // waveSurfer recognize value of `0` same as `1`*/}\n                {/*    //  so we need to set some zero-ish value for silence*/}\n                {/*    min=\"0.01\"*/}\n                {/*    max=\"1\"*/}\n                {/*    step=\".025\"*/}\n                {/*    onChange={onVolumeChange}*/}\n                {/*    defaultValue={volume}*/}\n                {/*/>*/}\n            </div>\n        </div>\n    );\n}",["121","122"],"/Users/parssa/Desktop/repos/mixbot/src/api/youtubeVideoContent.js",[],"/Users/parssa/Desktop/repos/mixbot/src/api/youtube.js",[],"/Users/parssa/Desktop/repos/mixbot/src/Deck.js",["123","124","125","126","127","128","129","130","131","132","133","134"],"/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Knob.js",[],"/Users/parssa/Desktop/repos/mixbot/src/api/keys.js",["135","136","137"],"const youtubeKey1 = \"AIzaSyC6F5gJnOX3mS2dl5-b_82PQ2ow7Xikuw8\"; // NotMixBot\n\nconst youtubeKey2 = \"AIzaSyCt7QrJ3-iInh6822WGi3Igo8J9gpH2WyA\"; // ThirdBot\n\nconst youtubeKey3 = \"AIzaSyBpT_RmX3P3wp_OMxiJT0SZIhkqFwMfVrA\"; // not set up yet\n\nconst youtubeKey4 = \"AIzaSyDgc98evXaE_C01NhK6ls2n7ZDkR - vg6sU\"; // backupPlan\n\n\nexport const currentKey = youtubeKey4;",["138","139"],"/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Queue.js",[],"/Users/parssa/Desktop/repos/mixbot/src/Mixbot.js",["140","141"],"import React, { useState } from 'react';\nimport TrackSelector from \"./TrackSelector\";\nimport TrackPlayer from \"./TrackPlayer\";\nimport QueueBox from \"./frontend_components/Queue\";\nimport Brain from \"./Brain\";\nimport axios from 'axios';\n\nlet tracklist = [];\nlet upcomingSongs = [];\nlet alreadyPlayed = [];\n\nconst baseURL = 'http://localhost:8080';\nconst addSongRefURL = baseURL + '/addSongRef'\n\n// --- Global Functions ---\nexport function trackAlreadyIn(trackName) {\n    console.log(\"checking if track is already in....\", trackName);\n    for (const trackObj of tracklist) {\n        console.log(trackObj.songName)\n        if (trackObj.songName === trackName)\n            return true;\n    }\n    return false;\n}\n\nexport function loadTrack() {\n    let nextSong = null;\n    if (upcomingSongs.length !== 0) {\n        nextSong = upcomingSongs[0].body;\n        alreadyPlayed.push(nextSong);\n        upcomingSongs.shift();\n    }\n    return nextSong;\n}\n\nexport function nextSongInQueue() {\n    return upcomingSongs[0] || null;\n}\n\nexport function tracklistSize() {\n    return tracklist.length;\n}\n\nexport const thoughtType = {\n    NEUTRAL: 1,\n    SUCCESS: 2,\n    FAILURE: 3,\n    MIX: 4\n}\n\nexport default function Mixbot() {\n    const [thoughts, setThoughts] = useState([]);\n\n    function newThought(input, type = thoughtType.NEUTRAL) {\n        // console.log(\"1. new thought added\", input);\n        let shouldShow = true;\n        if (thoughts.length > 0 && thoughts[thoughts.length - 1].body === input) {\n            shouldShow = false;\n        }\n        setThoughts([...thoughts, { id: \"THOUGHT-\" + thoughts.length, body: input, type: type, display: shouldShow }]);\n        // console.log(\"2. new thought added\", thoughts);\n    }\n\n    /**\n     * \n     * @param {*} songName: name of song\n     * @param {*} songArtists : array of artists of song\n     * @param {*} duration_ms: duration in ms \n     * @param {*} songURL: url to the temp reference link \n     * @param {*} analysis: raw spotify analysis \n     * @param {*} trackImage: img of album art \n     * @param {*} songID:  ID OF THE SPOTIFY SONG\n     * @param {*} videoID:  ID OF THE CORRESPONDING YT ID\n     * @param {boolean} fromDatabase: true if fetched yt id from database\n     */\n    async function addToQueue(songName, songArtists, duration_ms, songURL, analysis, trackImage, songID, videoID, fromDatabase) {\n\n        // TODO MAKE THIS ONLY HAPPEN IF NOT FOUND IN DATABASE\n        if (analysis !== \"NOTFOUND\") {\n            if (!fromDatabase) {\n                console.log(\"not in db yet, adding it...\");\n\n                let correctedArtists = [];\n                songArtists.forEach(artist => correctedArtists.push(artist.name));\n\n                let songRefEntry = {\n                    songID: songID, // spotify id\n                    videoID: videoID, // youtube videoID\n                    name: songName,\n                    artists: correctedArtists,\n                    duration: duration_ms,\n                }\n                addSongRefDB(songRefEntry);\n            } else {\n                console.log(\"got it from db!\");\n            }\n          \n            // Add it to the DB // todo\n            // let databaseEntry = {\n            // songID: songID,\n            // songName: songName,\n            // analyzed: analyzedData,\n            // }\n\n            // addTrackAnalysisDB(databaseEntry);\n\n        }\n\n        const newSong = {\n            songName: songName,\n            songArtists: songArtists,\n            duration_ms: duration_ms,\n            songURL: songURL,\n            songAnalysis: analysis,\n            trackImage: trackImage\n        }\n        console.log(\">>>(MIXBOT): NEW SONG IS:\", newSong);\n        console.log(\">>>(MIXBOT): ANALYSIS:\", analysis);\n        let packageSong = { id: \"tracklist\" + tracklist.length, body: newSong }\n        console.log(\">>>(MIXBOT): PACKAGED SONG:\", packageSong);\n        tracklist.push(packageSong);\n        console.log(\">>>(MIXBOT): ADDED TO TRACKLIST:\", tracklist);\n        upcomingSongs.push(packageSong);\n        console.log(\">>>(MIXBOT): ADDED TO UPCOMING SONGS:\", upcomingSongs);\n        const think = `Added ${songName} to the tracklist`;\n        console.log(\">>>(MIXBOT): ABOUT TO THINK:\", think);\n        newThought(think, thoughtType.NEUTRAL);\n    }\n\n    function addTrackAnalysisDB(entry) {\n        axios.create({\n            baseURL: 'http://localhost:8080',\n            headers: {}\n        }).get('/addAnalysis', {\n            params: {\n                data: entry\n            },\n        })\n    }\n\n    function addSongRefDB(entry) {\n        axios.get(addSongRefURL, {\n            params: { data: entry }\n        });\n    }\n\n\n    return (\n        <>\n            <TrackPlayer newThought={newThought} />\n            <div className=\"mixbot-dropdowns\">\n                <Brain decisions={thoughts} />\n                {tracklist.length == 0 ? null : <QueueBox items={tracklist} />}\n            </div>\n            <TrackSelector addToQueue={addToQueue} />\n        </>\n    )\n}\n","/Users/parssa/Desktop/repos/mixbot/src/Brain.js",[],"/Users/parssa/Desktop/repos/mixbot/src/helper_classes/Analyzer.js",["142","143","144","145","146","147"],"export const SectionType = {\n    DROP: 1,\n    REGULAR: 2,\n    COMEDOWN: 3,\n    BEGIN: 4,\n    UNSURE: 5\n}\n\nexport class Analyzer {\n    constructor() {\n        console.log(\"new analyzer created\");\n    }\n\n    /**\n     * Returns:\n     * {\n     *     songSections: All sections of the song, tagged with what they are\n            bars: Bars estimated through the data, used for syncing\n            startPos: Section the song should start\n     * }\n     */\n    analyzeSong(songData) {\n        console.log(\"analyzing data.\");\n        let analyzedBars = [];\n        let sectionArray = songData.sections;\n        let baselineLoudness = songData.track.loudness;\n        let allBars = songData.bars;\n        \n\n        let songSections = [];\n        let currSection = 0;\n\n        // song analysis variables\n        // let numDrops = 0;\n        // let mostConfidentDrop = 0;\n\n        // let numComedowns = 0;\n        // let mostConfidentComedown = 0;\n\n        // get an array of when all bars start\n        let barStartArray = []\n\n        let bar = allBars[0].duration;\n        let barConfidence = 0;\n        allBars.forEach(e => {\n            if (e.confidence > barConfidence) {\n                bar = e.duration;\n                barConfidence = e.confidence;\n            }\n        })\n        let barlength32 = bar * 2;\n        let songDuration = songData.track.duration;\n\n        let num32Bar = ((songDuration) / barlength32);\n\n        for (let a = 0; a <= num32Bar; a++) {\n            barStartArray.push(((a) * barlength32));\n        }\n\n        let calibrationArray = [];\n\n        let numCalibrationChunks = (songDuration) / bar;\n\n        for (let c = 0; c <= numCalibrationChunks; c++) {\n            calibrationArray.push(((c) * bar));\n        }\n\n\n        for (let b = 0; b < calibrationArray.length - 1; b++) {\n            // let barColor = (b % 2 ? \"rgba(255, 60, 54,0.05)\" : \"rgba(46, 255, 154,0.05)\");\n            let barRegion = {\n                start: calibrationArray[b],\n                end: calibrationArray[b + 1],\n                // color: barColor,\n                drag: false,\n                resize: false,\n                computed: {}\n            };\n            analyzedBars.push(barRegion); \n            // this.waveform.addRegion(barRegion);\n        }\n\n        sectionArray.forEach(e => {\n            currSection++;\n            let sectionType = SectionType.REGULAR;\n            let is32length = false;\n\n            let comparisonLoudness = (e.loudness - baselineLoudness) / baselineLoudness;\n\n            // IF BEGINNING OF SONG\n            if (songSections.length === 0) {\n                sectionType = SectionType.BEGIN;\n            }\n\n            // IF LOUD === DROP\n            if (comparisonLoudness < 0) {\n                sectionType = SectionType.DROP;\n            }\n\n            // IF LAST SONG WAS DROP AND DIFFERENTIAL OF THIS IS NEGATIVE === COMEDOWN\n            let diff = 0;\n            if (songSections.length > 0) {\n                diff = songSections[songSections.length - 1].computed.comparisonLoudness - comparisonLoudness;\n                if (songSections[songSections.length - 1].sectionType === SectionType.DROP) {\n                    if (sectionType === SectionType.DROP) {\n                        sectionType = SectionType.UNSURE;\n                    } else {\n                        sectionType = SectionType.COMEDOWN\n                    }\n                }\n            }\n\n            let beginpoint = e.start;\n            let endpoint = e.start + e.duration;\n            let closestEnd = this.closest(endpoint, barStartArray);\n            let closestBegin = this.closest(beginpoint, barStartArray);\n            let offsetBegin = closestBegin - beginpoint;\n            let offsetEnd = closestEnd - endpoint;\n            let acceptedConformEnd = false;\n            let acceptedConformBegin = false;\n\n            beginpoint = closestBegin;\n            endpoint = closestEnd;\n\n\n            let sizeComparison = ((endpoint - beginpoint) / barlength32).toPrecision(2); // checks if section is of calculated 32bar length\n            if (sizeComparison % 1) {\n                is32length = true;\n            }\n\n            let randomColor = 'rgba(162,254,231,0.3)';\n            switch (sectionType) {\n                case \"\":\n                    break;\n                case SectionType.BEGIN:\n                    // toLoop = true;\n                    randomColor = 'rgba(50,255,155,0.3)';\n                    if (is32length) {\n                        randomColor = 'rgba(100,255,55,0.3)';\n                    }\n                    break;\n                case SectionType.DROP:\n                    randomColor = 'rgba(237,61,155,0.3)';\n                    if (is32length) {\n                        randomColor = 'rgba(255,31,105,0.3)';\n                    }\n                    break;\n                case SectionType.COMEDOWN:\n                    randomColor = 'rgba(123,215,255,0.3)'\n                    if (is32length) {\n                        randomColor = 'rgba(50,150,255,0.3)'\n                    }\n                    break;\n                case SectionType.UNSURE:\n                    randomColor = 'rgba(34,1,255,0.2)'\n                    if (is32length) {\n                        randomColor = 'rgba(0,255,150,0.2)'\n                    }\n                    break;\n                default:\n                    break;\n            }\n\n            let goodForMix = false;\n            if (sectionType !== SectionType.DROP) {\n                if (comparisonLoudness > 0 && comparisonLoudness < 0.1) {\n                    randomColor = 'rgba(218, 165, 32,0.3)';\n                    goodForMix = true;\n                } else if (sectionType === SectionType.BEGIN) {\n                    randomColor = 'rgba(218, 165, 32,0.3)';\n                    goodForMix = true;\n                }\n            }\n            // ! THIS IS FOR UI PURPOSES REMOVE THIS WHEN TESTING\n            randomColor = 'rgba(0, 0, 0, 0)';\n\n            let analysisSection = {\n                sectionType: sectionType,\n                begin: beginpoint,\n                endpoint: endpoint,\n                computed: {\n                    comparisonLoudness: comparisonLoudness,\n                    differential: diff,\n                    sectionConfidence: e.confidence,\n                    conformedBegin: acceptedConformBegin,\n                    conformedEnd: acceptedConformEnd,\n                    oBegin: offsetBegin,\n                    oEnd: offsetEnd\n                },\n                sizeComparison: sizeComparison,\n                is32: is32length,\n                sectionColor: randomColor,\n                goodForMix: goodForMix\n            }\n            songSections.push(analysisSection);\n        })\n\n        let startingPos = 0; // TODO PASS THIS OUT\n\n        if (songSections.length > 2) {\n            // console.log(\"sec1:\", songSections[0].sizeComparison, \"sec2:\", songSections[1].sizeComparison);\n            // console.log(\"sec1:\", songSections[0].is32, \"sec2:\", songSections[1].is32);\n            if ((songSections[0].sizeComparison == 4) || (songSections[0].sizeComparison == 2 && songSections[1].sizeComparison == 2)) {\n                    startingPos= 0\n            } else if (songSections[0].sizeComparison == 2.0 && songSections[1].sizeComparison % 4 == 0) { // todo make this if songSections[1].sizeComparison is a multiple of 4\n                // console.log(\"mult of 4?\", songSections[1].sizeComparison % 4);\n                startingPos = songSections[0].endpoint;  \n            } \n        }\n\n        let finalAnalysis = {\n            songSections: songSections,\n            bars: calibrationArray,\n            startPos: startingPos,\n            tempo: songData.track.tempo,\n            loudness: baselineLoudness,\n            songKey: songData.track.key\n        }\n\n        return finalAnalysis;\n    }\n\n\n    closest(needle, haystack) {\n        let closeGrain = 100000000000000;\n        let grainCloseness = 100000000000000;\n        haystack.forEach(grain => {\n            let thisCloseness = Math.abs(needle - grain)\n            if (Math.abs(needle - grain) < grainCloseness) {\n                grainCloseness = thisCloseness;\n                closeGrain = grain;\n            }\n        })\n        return closeGrain;\n    }\n}",{"ruleId":"148","replacedBy":"149"},{"ruleId":"150","replacedBy":"151"},{"ruleId":"152","severity":1,"message":"153","line":1,"column":16,"nodeType":"154","messageId":"155","endLine":1,"endColumn":24},{"ruleId":"152","severity":1,"message":"156","line":1,"column":26,"nodeType":"154","messageId":"155","endLine":1,"endColumn":35},{"ruleId":"152","severity":1,"message":"157","line":5,"column":8,"nodeType":"154","messageId":"155","endLine":5,"endColumn":13},{"ruleId":"152","severity":1,"message":"158","line":47,"column":14,"nodeType":"154","messageId":"155","endLine":47,"endColumn":26},{"ruleId":"152","severity":1,"message":"159","line":64,"column":14,"nodeType":"154","messageId":"155","endLine":64,"endColumn":29},{"ruleId":"152","severity":1,"message":"160","line":1,"column":8,"nodeType":"154","messageId":"155","endLine":1,"endColumn":13},{"ruleId":"152","severity":1,"message":"161","line":4,"column":17,"nodeType":"154","messageId":"155","endLine":4,"endColumn":20},{"ruleId":"152","severity":1,"message":"162","line":4,"column":33,"nodeType":"154","messageId":"155","endLine":4,"endColumn":40},{"ruleId":"163","severity":1,"message":"164","line":105,"column":8,"nodeType":"165","endLine":105,"endColumn":23,"suggestions":"166"},{"ruleId":"163","severity":1,"message":"167","line":130,"column":8,"nodeType":"165","endLine":130,"endColumn":36,"suggestions":"168"},{"ruleId":"152","severity":1,"message":"169","line":1,"column":7,"nodeType":"154","messageId":"155","endLine":1,"endColumn":12},{"ruleId":"152","severity":1,"message":"170","line":4,"column":38,"nodeType":"154","messageId":"155","endLine":4,"endColumn":49},{"ruleId":"163","severity":1,"message":"171","line":39,"column":5,"nodeType":"154","endLine":39,"endColumn":14,"suggestions":"172"},{"ruleId":"173","severity":1,"message":"174","line":50,"column":27,"nodeType":"175","messageId":"176","endLine":50,"endColumn":29},{"ruleId":"173","severity":1,"message":"174","line":50,"column":47,"nodeType":"175","messageId":"176","endLine":50,"endColumn":49},{"ruleId":"173","severity":1,"message":"174","line":53,"column":34,"nodeType":"175","messageId":"176","endLine":53,"endColumn":36},{"ruleId":"173","severity":1,"message":"174","line":53,"column":54,"nodeType":"175","messageId":"176","endLine":53,"endColumn":56},{"ruleId":"148","replacedBy":"177"},{"ruleId":"150","replacedBy":"178"},{"ruleId":"152","severity":1,"message":"153","line":1,"column":16,"nodeType":"154","messageId":"155","endLine":1,"endColumn":24},{"ruleId":"152","severity":1,"message":"179","line":9,"column":12,"nodeType":"154","messageId":"155","endLine":9,"endColumn":19},{"ruleId":"163","severity":1,"message":"180","line":50,"column":8,"nodeType":"165","endLine":50,"endColumn":13,"suggestions":"181"},{"ruleId":"163","severity":1,"message":"182","line":66,"column":8,"nodeType":"165","endLine":66,"endColumn":19,"suggestions":"183"},{"ruleId":"148","replacedBy":"184"},{"ruleId":"150","replacedBy":"185"},{"ruleId":"152","severity":1,"message":"186","line":2,"column":8,"nodeType":"154","messageId":"155","endLine":2,"endColumn":12},{"ruleId":"152","severity":1,"message":"187","line":98,"column":13,"nodeType":"154","messageId":"155","endLine":98,"endColumn":18},{"ruleId":"173","severity":1,"message":"188","line":186,"column":93,"nodeType":"175","messageId":"176","endLine":186,"endColumn":95},{"ruleId":"189","severity":1,"message":"190","line":339,"column":13,"nodeType":"191","endLine":339,"endColumn":37},{"ruleId":"189","severity":1,"message":"190","line":340,"column":13,"nodeType":"191","endLine":340,"endColumn":45},{"ruleId":"189","severity":1,"message":"190","line":343,"column":13,"nodeType":"191","endLine":343,"endColumn":37},{"ruleId":"189","severity":1,"message":"190","line":344,"column":13,"nodeType":"191","endLine":344,"endColumn":46},{"ruleId":"189","severity":1,"message":"190","line":346,"column":13,"nodeType":"191","endLine":346,"endColumn":37},{"ruleId":"189","severity":1,"message":"190","line":347,"column":13,"nodeType":"191","endLine":347,"endColumn":45},{"ruleId":"189","severity":1,"message":"190","line":348,"column":13,"nodeType":"191","endLine":348,"endColumn":37},{"ruleId":"189","severity":1,"message":"190","line":349,"column":13,"nodeType":"191","endLine":349,"endColumn":46},{"ruleId":"189","severity":1,"message":"190","line":372,"column":9,"nodeType":"191","endLine":372,"endColumn":41},{"ruleId":"152","severity":1,"message":"192","line":1,"column":7,"nodeType":"154","messageId":"155","endLine":1,"endColumn":18},{"ruleId":"152","severity":1,"message":"193","line":3,"column":7,"nodeType":"154","messageId":"155","endLine":3,"endColumn":18},{"ruleId":"152","severity":1,"message":"194","line":5,"column":7,"nodeType":"154","messageId":"155","endLine":5,"endColumn":18},{"ruleId":"148","replacedBy":"195"},{"ruleId":"150","replacedBy":"196"},{"ruleId":"152","severity":1,"message":"197","line":130,"column":14,"nodeType":"154","messageId":"155","endLine":130,"endColumn":32},{"ruleId":"173","severity":1,"message":"174","line":153,"column":35,"nodeType":"175","messageId":"176","endLine":153,"endColumn":37},{"ruleId":"152","severity":1,"message":"198","line":84,"column":13,"nodeType":"154","messageId":"155","endLine":84,"endColumn":24},{"ruleId":"173","severity":1,"message":"174","line":203,"column":49,"nodeType":"175","messageId":"176","endLine":203,"endColumn":51},{"ruleId":"173","severity":1,"message":"174","line":203,"column":90,"nodeType":"175","messageId":"176","endLine":203,"endColumn":92},{"ruleId":"173","severity":1,"message":"174","line":203,"column":129,"nodeType":"175","messageId":"176","endLine":203,"endColumn":131},{"ruleId":"173","severity":1,"message":"174","line":205,"column":55,"nodeType":"175","messageId":"176","endLine":205,"endColumn":57},{"ruleId":"173","severity":1,"message":"174","line":205,"column":100,"nodeType":"175","messageId":"176","endLine":205,"endColumn":102},"no-native-reassign",["199"],"no-negated-in-lhs",["200"],"no-unused-vars","'useState' is defined but never used.","Identifier","unusedVar","'useEffect' is defined but never used.","'axios' is defined but never used.","'genreChanged' is defined but never used.","'playlistChanged' is defined but never used.","'React' is defined but never used.","'end' is defined but never used.","'pattern' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'videoIDtoMP3'. Either include it or remove the dependency array.","ArrayExpression",["201"],"React Hook useEffect has missing dependencies: 'checkDatabase', 'createSearchQuery', and 'getYoutubeVideo'. Either include them or remove the dependency array.",["202"],"'cred1' is assigned a value but never used.","'thoughtType' is defined but never used.","React Hook useEffect contains a call to 'setClock'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [clock] as a second argument to the useEffect Hook.",["203"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected",["199"],["200"],"'playing' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'volume'. Either include it or remove the dependency array. You can also do a functional update 'setVolume(v => ...)' if you only need 'volume' in the 'setVolume' call.",["204"],"React Hook useEffect has a missing dependency: 'handlePlayPause'. Either include it or remove the dependency array.",["205"],["199"],["200"],"'Knob' is defined but never used.","'dummy' is assigned a value but never used.","Expected '!==' and instead saw '!='.","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","'youtubeKey1' is assigned a value but never used.","'youtubeKey2' is assigned a value but never used.","'youtubeKey3' is assigned a value but never used.",["199"],["200"],"'addTrackAnalysisDB' is defined but never used.","'currSection' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"206","fix":"207"},{"desc":"208","fix":"209"},{"desc":"210","fix":"211"},{"desc":"212","fix":"213"},{"desc":"214","fix":"215"},"Update the dependencies array to be: [chosenVideoID, videoIDtoMP3]",{"range":"216","text":"217"},"Update the dependencies array to be: [name, artists, duration_ms, checkDatabase, createSearchQuery, getYoutubeVideo]",{"range":"218","text":"219"},"Add dependencies array: [clock]",{"range":"220","text":"221"},"Update the dependencies array to be: [url, volume]",{"range":"222","text":"223"},"Update the dependencies array to be: [handlePlayPause, isPlaying]",{"range":"224","text":"225"},[3901,3916],"[chosenVideoID, videoIDtoMP3]",[4749,4777],"[name, artists, duration_ms, checkDatabase, createSearchQuery, getYoutubeVideo]",[1369,1369],", [clock]",[1849,1854],"[url, volume]",[2436,2447],"[handlePlayPause, isPlaying]"]