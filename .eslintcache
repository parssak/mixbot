[{"/Users/parssa/Desktop/repos/mixbot/src/index.js":"1","/Users/parssa/Desktop/repos/mixbot/src/App.js":"2","/Users/parssa/Desktop/repos/mixbot/src/reportWebVitals.js":"3","/Users/parssa/Desktop/repos/mixbot/src/TrackSelector.js":"4","/Users/parssa/Desktop/repos/mixbot/src/TrackFinder.js":"5","/Users/parssa/Desktop/repos/mixbot/src/Credentials.js":"6","/Users/parssa/Desktop/repos/mixbot/src/TrackPlayer.js":"7","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Detail.js":"8","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Listbox.js":"9","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Dropdown.js":"10","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Waveform.js":"11","/Users/parssa/Desktop/repos/mixbot/src/api/youtubeVideoContent.js":"12","/Users/parssa/Desktop/repos/mixbot/src/api/youtube.js":"13","/Users/parssa/Desktop/repos/mixbot/src/Deck.js":"14","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Knob.js":"15","/Users/parssa/Desktop/repos/mixbot/src/api/keys.js":"16","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Queue.js":"17","/Users/parssa/Desktop/repos/mixbot/src/Mixbot.js":"18","/Users/parssa/Desktop/repos/mixbot/src/Brain.js":"19","/Users/parssa/Desktop/repos/mixbot/src/helper_classes/Analyzer.js":"20"},{"size":500,"mtime":1609255907946,"results":"21","hashOfConfig":"22"},{"size":968,"mtime":1610343348487,"results":"23","hashOfConfig":"22"},{"size":362,"mtime":1609255907947,"results":"24","hashOfConfig":"22"},{"size":6388,"mtime":1610345522466,"results":"25","hashOfConfig":"22"},{"size":4509,"mtime":1610345446952,"results":"26","hashOfConfig":"22"},{"size":315,"mtime":1610336027864,"results":"27","hashOfConfig":"22"},{"size":9508,"mtime":1610335668685,"results":"28","hashOfConfig":"22"},{"size":570,"mtime":1609255907945,"results":"29","hashOfConfig":"22"},{"size":814,"mtime":1610305380930,"results":"30","hashOfConfig":"22"},{"size":550,"mtime":1609255907945,"results":"31","hashOfConfig":"22"},{"size":3782,"mtime":1609255907946,"results":"32","hashOfConfig":"22"},{"size":767,"mtime":1610248130668,"results":"33","hashOfConfig":"22"},{"size":535,"mtime":1610299742890,"results":"34","hashOfConfig":"22"},{"size":17135,"mtime":1610335020403,"results":"35","hashOfConfig":"22"},{"size":4780,"mtime":1609255907945,"results":"36","hashOfConfig":"22"},{"size":354,"mtime":1610328014835,"results":"37","hashOfConfig":"22"},{"size":608,"mtime":1610376480379,"results":"38","hashOfConfig":"22"},{"size":5787,"mtime":1610376588940,"results":"39","hashOfConfig":"22"},{"size":1120,"mtime":1610376717223,"results":"40","hashOfConfig":"22"},{"size":8124,"mtime":1610329634878,"results":"41","hashOfConfig":"22"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"11p3aqi",{"filePath":"45","messages":"46","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"44"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"44"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55","usedDeprecatedRules":"44"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"44"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61","usedDeprecatedRules":"44"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68","usedDeprecatedRules":"44"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"72"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79","usedDeprecatedRules":"44"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"84","usedDeprecatedRules":"85"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"90","usedDeprecatedRules":"44"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"95","usedDeprecatedRules":"44"},"/Users/parssa/Desktop/repos/mixbot/src/index.js",[],["96","97"],"/Users/parssa/Desktop/repos/mixbot/src/App.js",["98","99","100"],"import React, {useState, useEffect} from 'react';\nimport './css_files/App.css';\nimport Mixbot from './Mixbot';\n\nimport axios from 'axios';\n\nfunction App() {\n\n    // function makeRequest() {\n    //     console.log(\"boutta make request\");\n    //     axios.create({\n    //         baseURL: 'http://localhost:8080',\n    //         headers: {}\n    //     }).get('/addEntry', {\n    //         params: {\n    //             songEntry: {\n    //                 name: \"AHA AHA AHA\"\n    //             }\n    //         },\n    //     })\n    // }\n\n    return(\n        <div className={\"body\"}>\n            <div className={\"title\"}>\n                <h1>MIXBOT</h1>\n                <div className={\"credits\"}>\n                    {/* <button onClick={() => { makeRequest() }}>Make request</button> */}\n                    <h3>An Open Source project by Parssa Kyanzadeh</h3> \n                 </div>\n            </div>\n            <Mixbot/>\n        </div>\n    );\n}\nexport default App;\n","/Users/parssa/Desktop/repos/mixbot/src/reportWebVitals.js",[],"/Users/parssa/Desktop/repos/mixbot/src/TrackSelector.js",["101","102","103","104","105","106"],"import React, { useState, useEffect } from 'react';\nimport Dropdown from \"./frontend_components/Dropdown\";\nimport { Credentials } from './Credentials';\nimport axios from 'axios';\nimport Listbox from \"./frontend_components/Listbox\";\nimport Detail from \"./frontend_components/Detail\";\nimport TrackFinder from \"./TrackFinder\";\nimport { nextSongInQueue, thoughtType, trackAlreadyIn, tracklistSize} from \"./Mixbot\";\n\nconst euroHouseID = \"2818tC1Ba59cftJJqjWKZi\";\n\nfunction TrackSelector({addToQueue}) {\n    const spotify = Credentials();\n    const [token, setToken] = useState('');\n    const [genres, setGenres] = useState({ selectedGenre: '', listOfGenresFromAPI: [] });\n    const [playlist, setPlaylist] = useState({ selectedPlaylist: euroHouseID, listOfPlaylistFromAPI: [] });\n    const [tracks, setTracks] = useState({ selectedTrack: '', listOfTracksFromAPI: [] });\n    const [trackDetail, setTrackDetail] = useState(null);\n\n    useEffect(() => {\n        axios('https://accounts.spotify.com/api/token', {\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                'Authorization': 'Basic ' + btoa(spotify.ClientId + ':' + spotify.ClientSecret)\n            },\n            data: 'grant_type=client_credentials',\n            method: 'POST'\n        })\n            .then(tokenResponse => {\n                setToken(tokenResponse.data.access_token);\n                console.log(\"got ma token\");\n                // axios('https://api.spotify.com/v1/browse/categories', {\n                //     method: 'GET',\n                //     headers: { 'Authorization' : 'Bearer ' + tokenResponse.data.access_token}\n                // })\n                //     .then (genreResponse => {\n                //         console.log(genreResponse)\n                //         setGenres({\n                //             selectedGenre: genres.selectedGenre,\n                //             listOfGenresFromAPI: genreResponse.data.categories.items\n                //         })\n                //     });\n\n            });\n\n    }, [genres.selectedGenre, spotify.ClientId, spotify.ClientSecret]);\n\n    function genreChanged(val) {\n        setGenres({\n            selectedGenre: val,\n            listOfGenresFromAPI: genres.listOfGenresFromAPI\n        });\n\n        axios(`https://api.spotify.com/v1/browse/categories/${val}/playlists?limit=30`, {\n            method: 'GET',\n            headers: { 'Authorization': 'Bearer ' + token }\n        }).then(playlistResponse => {\n            setPlaylist({\n                selectedPlaylist: playlist.selectedPlaylist,\n                listOfPlaylistFromAPI: playlistResponse.data.playlists.items\n            })\n        });\n    }\n\n    function playlistChanged(val) {\n        setPlaylist({\n            selectedPlaylist: val,\n            listOfPlaylistFromAPI: playlist.listOfPlaylistFromAPI\n        });\n    }\n\n    function playlistSearchClicked(e) {\n        e.preventDefault();\n        console.log(\"selected playlist was\" + playlist.selectedPlaylist);\n        axios(`https://api.spotify.com/v1/playlists/${playlist.selectedPlaylist}/tracks?limit=40`, {\n            method: 'GET',\n            headers: {\n                'Authorization': 'Bearer ' + token\n            }\n        }).then(tracksResponse => {\n            setTracks({\n                selectedTrack: tracks.selectedTrack,\n                listOfTracksFromAPI: tracksResponse.data.items\n            })\n        });\n    }\n\n    function selectTrack(val) {\n        const currentTracks = [...tracks.listOfTracksFromAPI];\n        const trackInfo = currentTracks.filter(t => t.track.id === val);\n        if (!trackAlreadyIn(trackInfo[0].track.name)) {\n            console.log(\">>>\",trackInfo[0].track);\n            setTrackDetail(trackInfo[0].track);\n        } else {\n            console.log(\"track is already in the queue\");\n        }\n    }\n\n    async function addSongToTracklist(songName, songArtists, duration, songURL, trackID, trackImage, youtubeVideoID) {\n        if (!trackAlreadyIn(songName)) {\n            console.log(\"adding: \" + songName + \"with id \" + trackID);\n            await getAudioAnalysis(trackID, songName, songArtists, duration, songURL, trackImage, youtubeVideoID);\n        } else {\n            console.log(\"track is already in the queue\");\n            setTrackDetail(null);\n        }\n    }\n\n    async function checkForSong(songID) {\n        console.log(\"boutta check dis\");\n        return axios.create({\n            baseURL: 'http://localhost:8080',\n            headers: {}\n        }).get('/checkForEntry', {\n            params: {\n               songID: songID\n            },\n        })\n    }\n\n    const getAudioAnalysis = async (id, songName, songArtists, duration, songURL, trackImage, youtubeVideoID) => {\n        console.log(\"song id is \" + id);\n\n        // TODO CHECK IF DB CONTAINS SONG\n        // axios(``)\n\n        axios(`https://api.spotify.com/v1/audio-analysis/${id}`, {\n            method: 'GET',\n            headers: {\n                'Authorization': 'Bearer ' + token\n            }\n        }).then(e => {\n            \n            addToQueue(songName, songArtists, duration, songURL, e, trackImage, id, youtubeVideoID);\n        }).catch(e => {\n            // addToQueue(songName, songArtists, duration, songURL, \"NOTFOUND\", trackImage);\n            //! TODO DEAL WITH THIS PROPERLY\n        }).finally(() => {\n            setTrackDetail(null);\n        });\n    }\n\n    return (\n        <div style={{ marginTop: \"15em\" }}>\n            <button onClick={async () => {\n                let a = await checkForSong(\"bababooei\");\n                console.log(a);\n            }}>Make request</button>\n            <form onSubmit={playlistSearchClicked}>\n                {tracklistSize() === 0 && <button type='submit' className=\"begin-mix\">BEGIN MIX</button>}\n                <div style={{ marginTop: \"4em\" }}>\n                    <Listbox items={tracks.listOfTracksFromAPI} clicked={selectTrack} />\n                    {trackDetail && <TrackFinder name={trackDetail.name}\n                        artists={trackDetail.artists}\n                        duration_ms={trackDetail.duration_ms}\n                        trackID={trackDetail.id}\n                        trackImage={trackDetail.album.images[1]}\n                        foundSong={addSongToTracklist} />}\n                </div>\n            </form>\n        </div>\n    );\n}\n\nexport default TrackSelector;\n","/Users/parssa/Desktop/repos/mixbot/src/TrackFinder.js",["107","108","109","110","111","112"],"import React, { useEffect, useState } from 'react';\nimport youtubeApi from './api/youtube'\nimport videoDetailFinder from './api/youtubeVideoContent'\nimport { parse, end, toSeconds, pattern } from 'iso8601-duration';\n\n/**\n * This class handles finding a track based on song name, artists, and duration\n * and calls the foundSong prop when a song has been found.\n *\n * @param name: Name of the Song\n * @param artists: An array of artist objects\n * @param duration_ms: The duration of the song in milliseconds\n * @param foundSong: A prop that gets called when song has been found\n * @param trackID:\n */\nlet lastChosenID = \"\";\nexport default function TrackFinder({ name, artists, duration_ms, foundSong, trackID, trackImage }) {\n\n    const [songName, setSongName] = useState(name);\n    const [songArtists, setSongArtists] = useState(artists);\n    const [duration, setDuration] = useState(duration_ms);\n    const [chosenVideoID, setChosenVideoID] = useState(\"\");\n\n    function createSearchQuery() {\n        let artistNames = [];\n        artists.forEach(e => {\n            const thisName = e.name;\n            if (thisName) {\n                artistNames.push(thisName)\n            }\n        });\n        let searchQuery = name + \" by \" + artistNames[0];\n        return searchQuery;\n    }\n\n\n    async function videosSearch(search) {\n        const response = await youtubeApi.get(\"/youtubeSearch\", { // TODO CHANGE THIS TO SERVER\n            params: {\n                q: search\n            }\n        })\n        return response;\n    }\n\n    async function videoDetail(videoID) {\n        const response = await videoDetailFinder.get(\"/youtubeDetail\", {\n            params: {\n                id: videoID\n            }\n        })\n        return response;\n    }\n\n    /**\n     * Searches YouTube for song using search query, breaks when found is song\n     * @param searchQuery\n     * @returns {Promise<void>}\n     */\n    async function getYoutubeVideo(searchQuery) {\n        videosSearch(searchQuery).then(async e => {\n            const videoList = e.data.items;                                                     // a list of videos                 \n            for (let video = 0; video < videoList.length; video++) {                            // for each video in the videoList...\n                console.log(\">>>>>>>>\", chosenVideoID, \"<<<<<<<<<\");\n                const thisDetails = await videoDetail(videoList[video].id.videoId);             // Get details...\n                const thisDur = toMilli(thisDetails.data.items[0].contentDetails.duration);     // Get duration from details...\n                if (Math.abs(duration - thisDur) <= 1000) {                                     // If the duration is what we're looking for...\n                    console.log(\">>>>>>>> BINGO! <<<<<<<<<\");\n                    setChosenVideoID(videoList[video].id.videoId); // TODO FIX THIS OMG THIS IS AN ABSOLUTE ABUSE OF STATE.\n                    break;\n                }\n            }\n        })\n    }\n\n    /**\n     * Helper function for converting ISO8 8601 time to milliseconds\n     * @param ISO: ISO time\n     * @returns {the ISO time in milliseconds}\n     */\n    function toMilli(ISO) {\n        return toSeconds(parse(ISO)) * 1000;\n    }\n\n    /**\n     * This effect triggers when the chosenVideoID is\n     * found, and then get the URL for mp3 download\n     *\n     * Since this effect gets called over once for the\n     * same video being found sometimes, it will not\n     * convert the video to mp3 if it has already been\n     * called once for this current song\n     * >> “ \"lastChosenID === \"\" ”\n     */\n    useEffect(() => {\n\n        if (chosenVideoID && lastChosenID === \"\") {\n            lastChosenID = chosenVideoID;\n            videoIDtoMP3(chosenVideoID);\n        }\n\n    }, [chosenVideoID])\n\n    useEffect(async () => {          // TODO FIX WHEN AVAILABLE\n        setSongArtists(artists);\n        setSongName(name);\n        setDuration(duration_ms);\n        lastChosenID = \"\";\n        const search = createSearchQuery();\n        await getYoutubeVideo(search);\n    }, [name, artists, duration_ms]);\n\n    async function videoIDtoMP3(videoID) {\n        videoDetailFinder.get('/youtubeMp3', {\n            params: {\n                id: videoID\n            }\n        }).then(response => {\n            let audioFormats = response.data;\n            foundSong(songName, songArtists, duration, audioFormats[0].url, trackID, trackImage, videoID);\n            setChosenVideoID(\"\");\n        });\n    }\n\n    return null;\n}","/Users/parssa/Desktop/repos/mixbot/src/Credentials.js",["113"],"const cred1 = {\n    ClientId: '2f960da39c8b42d9a8dc394d02b97db0',\n    ClientSecret: '860fabcadd034f1d9368e7ca7791de73'\n}\n\n\nconst cred2 = {\n    ClientId: '75cbbf8c1ff14b9abe3cbfe6924fb5f0',\n    ClientSecret: 'da55e142b302460cab9b737153b93eb4'\n}\n\n\nfunction Credentials() {\n    return cred2;\n}\n\nexport { Credentials };","/Users/parssa/Desktop/repos/mixbot/src/TrackPlayer.js",["114","115","116","117","118","119"],"import React, { useEffect, useState } from 'react';\nimport Deck from \"./Deck\";\nimport './css_files/Queue.scss';\nimport { loadTrack, nextSongInQueue, thoughtType } from \"./Mixbot\";\n\n// let deck1playtime = NaN;\n// let deck2playtime = NaN;\n\nlet deck1startTime = 0;\nlet deck2startTime = 0;\n\nlet lastTrackSet = 0;\nlet mainTrack = 0;\n\nlet deck1lastBar = 0;\nlet deck2lastBar = 0;\n\nexport default function TrackPlayer({newThought}) {\n    const [clock, setClock] = useState();\n\n    const [deck1Song, setDeck1Song] = useState('');\n    const [deck2Song, setDeck2Song] = useState('');\n\n    const [deck1BPM, setDeck1BPM] = useState(0);\n    const [deck2BPM, setDeck2BPM] = useState(0);\n\n    const [deck1playback, setDeck1playback] = useState(1);\n    const [deck2playback, setDeck2playback] = useState(1);\n\n    const [deck1prepared, setDeck1prepared] = useState(false);\n    const [deck2prepared, setDeck2prepared] = useState(false);\n\n    const [deck1Playing, setDeck1Playing] = useState(false);\n    const [deck2Playing, setDeck2Playing] = useState(false);\n\n    const [deck1offset, setDeck1offset] = useState(0);\n    const [deck2offset, setDeck2offset] = useState(0);\n\n    useEffect(() => {\n        console.log(\"-----------------player did update!-----------------\");\n        if (!clock) {\n            let newClock = new AudioContext();\n            setClock(newClock);\n        } \n    })\n\n    useEffect(() => {\n        if (nextSongInQueue() !== null) {\n            console.log(\">>> theres a song in the queue!\", nextSongInQueue());\n            if ((deck1BPM == 0) && (deck1Song == '')) {\n                console.log(\">> putting it in track a\");\n                loadTrackA();\n            } else if ((deck2BPM == 0) && (deck2Song == '')) {\n                console.log(\">> putting it in track b\");\n                loadTrackB();\n            }\n        }\n    })\n\n    function loadTrackA() {\n        let newSong = loadTrack();\n        setDeck1prepared(false);\n        setDeck1Playing(false);\n        if (newSong !== null) {\n            console.log(\"new\");\n            console.log(newSong);\n            setDeck1BPM(Math.round(newSong.songAnalysis.data.track.tempo)) // terribly sus\n            if (deck2Song === '') {\n                setDeck1playback(1);\n            } else {\n                if (deck2BPM !== 0) {\n                    let ratio = (deck2BPM / newSong.songAnalysis.data.track.tempo).toPrecision(5);\n                    setDeck1playback(ratio);\n                } else {\n                    setDeck1playback(1);\n                }\n            }\n            console.log(\"> , --------------------------->> \", newSong);\n            let think = \"Put \" + newSong.songName + \" on Deck A\";\n            newThought(think);\n            setDeck1Song(newSong);\n        }\n        else {\n            console.log(\"new song was null\");\n        }\n    }\n\n    function loadTrackB() {\n        let newSong = loadTrack();\n        setDeck2prepared(false);\n        setDeck2Playing(false);\n        if (newSong !== null) {\n            setDeck2BPM(Math.round(newSong.songAnalysis.data.track.tempo)) // terribly sus\n            console.log(\">>>>>            here comes the next song\", newSong);\n            if (deck1Song === '') {\n                setDeck2playback(1);\n            } else {\n                if (deck1BPM !== 0) {\n                    let ratio = (deck1BPM / Math.round(newSong.songAnalysis.data.track.tempo)).toPrecision(5);\n                    setDeck2playback(ratio);\n                } else {\n                    setDeck2playback(1);\n                }\n            }\n            let think = \"Put \" + newSong.songName + \" on Deck B\";\n            newThought(think);\n            setDeck2Song(newSong)\n        } else {\n            console.log(\"new song was null\");\n        }\n    }\n\n    function deckOneReady() {\n        if (!deck1prepared) {\n            setDeck1prepared(true);\n            console.log(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SETTING D1READY\");\n            if (!deck2Playing) {\n                console.log(\"telling deck 1 to play\");\n                setDeck1Playing(true);\n            }\n        }\n    }\n\n    function deckTwoReady() {\n        if (!deck2prepared) {\n            setDeck2prepared(true);\n            console.log(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SETTING D2READY\");\n            if (!deck1Playing) {\n                console.log(\"telling deck 2 to play\");\n                setDeck2Playing(true);\n            }\n        }\n    }\n\n    // function playDeck2SongScheduled(timeoutValue) {\n    //     console.log(\"setting timeout for:\", timeoutValue);\n    //     setTimeout(function () {\n    //         console.log(clock.currentTime, deck2playtime);\n    //         console.log(\"checkin time bois\", deck2playtime - clock.currentTime);\n    //         if (deck2playtime - clock.currentTime <= 0) {\n    //             deck2startTime = deck2playtime - clock.currentTime;\n    //             setDeck2Playing(true);\n    //         } else {\n    //             console.log(deck2playtime - clock.currentTime);\n    //             if ((deck2playtime - clock.currentTime) <= 0.5) {\n    //                 console.log(\"case a \");\n    //                 playDeck2SongScheduled(500);\n    //             } else {\n    //                 console.log(\"case b \");\n    //                 playDeck2SongScheduled((deck2playtime - clock.currentTime) / 2);\n    //             }\n    //         }\n    //     }, timeoutValue)\n    // }\n\n    function playTrackTwo() {\n        if (deck2prepared) {\n            console.log(\"+++ deck TWO is prepared, gonna play it!\");\n            setDeck2Playing(true);\n            setDeck2prepared(false);\n            if (lastTrackSet === 0) {\n                lastTrackSet = 2;\n                mainTrack = 1;\n            }\n        }\n    }\n\n    function playTrackOne() {\n        if (deck1prepared) {\n            console.log(\"+++ deck ONE is prepared, gonna play it!\");\n            setDeck1Playing(true);\n            setDeck1prepared(false);\n            if (lastTrackSet === 0) {\n                lastTrackSet = 1;\n                mainTrack = 1;\n            }\n\n        }\n    }\n\n    function hitBarD1() {\n        deck1lastBar = clock.currentTime;\n        if (deck2Playing) {\n            console.log(\"DECK1\", deck1offset);\n            setDeck1offset(deck2lastBar - deck1lastBar);\n        }\n    }\n\n    function hitBarD2() {\n        deck2lastBar = clock.currentTime;\n        if (deck1Playing) {\n            console.log(\"DECK2\", deck2offset);\n            setDeck2offset(deck1lastBar - deck2lastBar);\n        }\n    }\n\n    function changeTrackA() {\n        mainTrack = 2;\n        setDeck2playback(1);\n        loadTrackA();\n    }\n\n    function changeTrackB() {\n        mainTrack = 1;\n        setDeck1playback(1);\n        loadTrackB();\n    }\n\n    return (\n        <>\n            <div className={\"djboard\"}>\n                <div className={\"boardpanel\"} style={deck1Playing ? { boxShadow: \"0 3px 100px rgba(255, 99, 71, 0.3)\" } : { boxShadow: \"0 0 0 rgba(255, 99, 71, 0.3)\" }}>\n                    <h3>DECK A</h3>\n                    {deck1Song !== '' && <Deck\n                        thisSong={deck1Song.songURL}\n                        songName={deck1Song.songName}\n                        songArtist={deck1Song.songArtists[0].name}\n                        songImage={deck1Song.trackImage}\n                        songAnalysis={deck1Song.songAnalysis}\n                        playbackRate={deck1playback}\n                        prepared={deckOneReady}\n                        play={deck1Playing}\n                        startTime={deck1startTime}\n                        playOtherTrack={playTrackTwo}\n                        hitBar={hitBarD1}\n                        offset={deck1offset}\n                        deckName={\"Deck A\"}\n                        finished={changeTrackA}\n                        recommendedVolume={1}\n                        shouldSync={mainTrack !== 1}\n                        otherReady={deckTwoReady}\n                        waveformID={\"waveformA\"}\n                        bpm={deck1BPM}\n                        newThought={newThought}\n                    />\n                    }\n\n                </div>\n                <div className={\"boardpanel\"} style={deck2Playing ? { boxShadow: \"0 3px 100px rgba(255, 99, 71, 0.3)\" } : { boxShadow: \"0 0 0 rgba(255, 99, 71, 0.3)\" }}>\n                    <h3 style={{ textAlign: 'right' }}>DECK B</h3>\n                    {deck2Song !== '' && <Deck\n                        thisSong={deck2Song.songURL}\n                        songName={deck2Song.songName}\n                        songArtist={deck2Song.songArtists[0].name}\n                        songImage={deck2Song.trackImage}\n                        songAnalysis={deck2Song.songAnalysis}\n                        playbackRate={deck2playback}\n                        prepared={deckTwoReady}\n                        play={deck2Playing}\n                        startTime={deck2startTime}\n                        playOtherTrack={playTrackOne}\n                        hitBar={hitBarD2}\n                        offset={deck2offset}\n                        deckName={\"Deck B\"}\n                        finished={changeTrackB}\n                        recommendedVolume={1}\n                        shouldSync={mainTrack !== 2}\n                        otherReady={deckOneReady}\n                        waveformID={\"waveformB\"}\n                        bpm={deck2BPM}\n                        newThought={newThought}\n                    />}\n                </div>\n            </div>\n        </>\n    );\n}","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Detail.js",[],"/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Listbox.js",[],"/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Dropdown.js",["120"],"import React, {useState} from 'react';\n\nconst Dropdown = props => {\n\n    const dropdownChanged = e => {\n        props.changed(e.target.value);\n\n    }\n\n    return (\n        <div className=\"dropdown\">\n            <label>{props.label}</label>\n            <select value={props.selectedValue} onChange={dropdownChanged}>\n                <option key={0}>Select...</option>\n                {props.options.map((item, idx) => <option key={idx + 1} value={item.id}>{item.name}</option>)}\n            </select>\n        </div>\n    );\n}\n\nexport default Dropdown;\n","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Waveform.js",["121","122","123"],"import React, { useEffect, useRef, useState } from \"react\";\nimport WaveSurfer from 'wavesurfer.js';\n\n//https://codesandbox.io/s/audio-player-with-wavesurferjs-react-bd499?from-embed=&file=/src/Waveform.js:0-60\n\nexport default function Waveform({ url, onPositionChange, isPlaying, audioCtx, lowpassNum }) {\n    const waveformRef = useRef(null);\n    const wavesurfer = useRef(null);\n    const [playing, setPlay] = useState(false);\n    const [volume, setVolume] = useState(0.5);\n    const formWaveSurferOptions = ref => ({\n        container: ref,\n        waveColor: \"#beb9b9\",\n        progressColor: \"#9a68c9\",\n        cursorColor: \"#dac4f0\",\n        hideScrollbar: true,\n        responsive: true,\n        partialRender: true,\n        normalize: true,\n        height:200\n    });\n\n    // create new WaveSurfer instance\n    // On component mount and when url changes\n    useEffect(() => {\n        setPlay(false);\n\n        const options = formWaveSurferOptions(waveformRef.current);\n        wavesurfer.current = WaveSurfer.create(options);\n        wavesurfer.current.load(url.src);\n        wavesurfer.current.on(\"ready\", function() {\n            // https://wavesurfer-js.org/docs/methods.html\n            // wavesurfer.current.play();\n            // setPlay(true);\n\n            // make sure object still available when file loaded\n            if (wavesurfer.current) {\n                wavesurfer.current.setVolume(volume);\n                setVolume(volume);\n            }\n            let lowpass = wavesurfer.backend.ac.createBiquadFilter();\n            lowpass.type = \"lowpass\";\n            lowpass.frequency.value = 10;\n            wavesurfer.current.backend.setFilter(lowpass);\n        });\n\n        // Removes events, elements and disconnects Web Audio nodes.\n        // when component unmount\n        return () => wavesurfer.current.destroy();\n    }, [url]);\n\n    useEffect(() => {\n        console.log(\"!!!\")\n        handlePlayPause();\n        console.log(wavesurfer.current.getFilters());\n        // if (isPlaying !== playing) {\n        //     handlePlayPause();\n        // }\n        // wavesurfer.current.on('audioprocess', function () {\n        //     // $('.waveform__counter').text( formatTime(wavesurfer.getCurrentTime()) );\n        //     // console.log(wavesurfer.current.getCurrentTime());\n        //     // console.log(\"--\")\n        //     onPositionChange(wavesurfer.current.getCurrentTime());\n        //\n        // });\n    }, [isPlaying]);\n\n    useEffect( () => {\n        console.log(\"lowpass\", lowpassNum);\n\n    }, [lowpassNum])\n\n\n    const handlePlayPause = () => {\n        console.log(\"switching this\");\n        setPlay(isPlaying);\n        wavesurfer.current.playPause();\n    };\n\n    // const onVolumeChange = e => {\n    //     const { target } = e;\n    //     const newVolume = +target.value;\n    //\n    //     if (newVolume) {\n    //         setVolume(newVolume);\n    //         wavesurfer.current.setVolume(newVolume || 1);\n    //     }\n    // };\n\n    return (\n        <div className={\"waveform-comp\"}>\n            <div id=\"waveform\" ref={waveformRef} />\n            <div className=\"controls\">\n                {/*<button onClick={handlePlayPause}>{!playing ? \"Play\" : \"Pause\"}</button>*/}\n                {/*<input*/}\n                {/*    type=\"range\"*/}\n                {/*    id=\"volume\"*/}\n                {/*    name=\"volume\"*/}\n                {/*    // waveSurfer recognize value of `0` same as `1`*/}\n                {/*    //  so we need to set some zero-ish value for silence*/}\n                {/*    min=\"0.01\"*/}\n                {/*    max=\"1\"*/}\n                {/*    step=\".025\"*/}\n                {/*    onChange={onVolumeChange}*/}\n                {/*    defaultValue={volume}*/}\n                {/*/>*/}\n            </div>\n        </div>\n    );\n}",["124","125"],"/Users/parssa/Desktop/repos/mixbot/src/api/youtubeVideoContent.js",[],"/Users/parssa/Desktop/repos/mixbot/src/api/youtube.js",[],"/Users/parssa/Desktop/repos/mixbot/src/Deck.js",["126","127","128","129","130","131","132","133","134","135","136","137"],"import React, { Component } from 'react';\nimport Knob from './frontend_components/Knob';\nimport WaveSurfer from 'wavesurfer.js';\nimport RegionPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.regions.min.js';\nimport './css_files/Deck.scss';\nimport { SectionType } from './helper_classes/Analyzer';\nimport { thoughtType } from './Mixbot';\n\nlet xhr = { cache: 'default', mode: 'cors', method: 'GET', credentials: 'same-origin', redirect: 'follow', referrer: 'client', headers: [{ 'Access-Control-Allow-Origin': '*' }] };\n\nexport default class Deck extends Component {\n    constructor(props) {\n        super(props);\n        console.log(\"entered constructor call!\");\n        this.state = {\n            pos: 0,\n            locked: false,\n            scheduledDemise: false,\n            currSec: \"NOT PLAYING\",\n            playing: false,\n            trackName: this.props.songName,\n            trackArtist: this.props.songArtist,\n            audioCtx: new AudioContext(),\n            // audioElement: new Audio(this.props.thisSong),\n            audioSettings: {\n                gain: 1,\n                lowpassF: 11000,\n                highpassF: 0,\n                high: 1,\n                mid: 1,\n                low: 1,\n                playbackRate: this.props.playbackRate\n            },\n            currSectionAnalysis: {\n                begin: NaN,\n                endpoint: NaN,\n                comparisonLoudness: NaN,\n                differential: NaN,\n                sectionConfidence: NaN,\n                conformedBegin: NaN,\n                conformedEnd: NaN,\n                oBegin: NaN,\n                oEnd: NaN,\n                sectionColor: `rgb(255,255,255)`,\n                goodForMix: false,\n                isBest: false\n            },\n            startingPos: 0\n        };\n\n        this.waveSurferOptions = {\n            container: `#${this.props.waveformID}`,\n            waveColor: \"#ffffff\",\n            cursorColor: \"tomato\",\n            hideScrollbar: true,\n            normalize: true,\n            height: 70,\n            barWidth: 1,\n            barHeight: 0.5, // the height of the wave\n            barRadius: 2,\n            plugins: [\n                RegionPlugin.create(),\n            ],\n            xhr: xhr\n        }\n\n        this.lastAdjustTime = 0;\n        this.synced = false;\n        this.fadingOut = false;\n        this.fadingIn = false;\n        this.totalOffset = 0;\n        this.numSuccessful = 0;\n        this.numDropsPassed = 0;\n\n        this.playPause = this.playPause.bind(this);\n        this.fadeOutSong = this.fadeOutSong.bind(this);\n        this.changeFilter = this.changeFilter.bind(this);\n        this.changeGain = this.changeGain.bind(this);\n        this.reconnectAudio = this.reconnectAudio.bind(this);\n        this.handlePosChange = this.handlePosChange.bind(this);\n    }\n\n    componentDidMount() {\n        console.log(\"|| ---- COMPONENT DID MOUNT ---- ||\", this.props.deckName);\n        // wavesurfer begins here\n        this.waveform = WaveSurfer.create(this.waveSurferOptions);\n\n\n        this.waveform.on('loading', e => {\n            console.log(\"loading:\", e);\n        })\n\n        this.waveform.on('error', e => {\n            console.log(\"hit error:\", e);\n        })\n      \n        console.log(\"MOUNT THISSONG>>>\",this.props.thisSong);\n        let dummy = new Audio(this.props.thisSong);\n        // console.log(\">>>!!!>>>\", dummy.src);\n        // console.log(\">>>>!!!!???\", dummy.src === this.props.thisSong);\n        this.waveform.load(this.props.thisSong);\n\n        // console.log(this.props.thisSong);\n        // let ooga = this.props.thisSong;\n        // console.log(\"ooga is:\", ooga);\n        // console.log(\"song src WAS:\", song.src);\n        // // song.src = this.props.thisSong;\n        // song.crossOrigin = \"anonymous\";\n        // console.log(\"loading song in mount >>>!\", this.props.thisSong);\n        \n        // this.waveform.load(\"http://ia902606.us.archive.org/35/items/shortpoetry_047_librivox/song_cjrg_teasdale_64kb.mp3\");\n        console.log(\"loaded song\", this.waveform.src);\n        this.waveform.setPlaybackRate(this.props.playbackRate);\n        this.reconnectAudio();\n    }\n\n    componentDidUpdate(prevProps) {\n        console.log(\"||| ---- COMPONENT DID UPDATE ---- |||\", this.props.deckName);\n        console.log(\"TRACK IMG:\", this.props.songImage)\n        if (this.props.thisSong !== prevProps.thisSong) { // TODO LEFT OFF HERE, YOU WERE TRYING TO MAKE SWITCHING SONGS ON A SINGLE DECK WORK BC IT KEEPS PLAYING THE OLD ONE ALSO REGIONS AREN\"T DISAPPEARING\n            console.log(\"|| -- THE SONG CHANGED -- ||\", this.props.deckName);\n            this.waveform.pause();\n\n            this.synced = false;\n            this.numSuccessful = 0;\n            this.totalOffset = 0;\n            this.fadingOut = false;\n            this.fadingIn = false;\n            this.numDropsPassed = 0;\n\n            this.waveform.destroy();\n\n            this.waveform = WaveSurfer.create(this.waveSurferOptions);\n            this.waveform.on('loading', e => {\n                console.log(\"loading:\", e);\n            })\n\n            this.waveform.on('error', e => {\n                console.log(\"hit error:\", e);\n            })\n\n            console.log(\"loading song in update >>>!\", this.props.thisSong);\n            let dummy = new Audio(this.props.thisSong);\n            this.waveform.load(dummy.src);\n            this.waveform.setPlaybackRate(this.props.playbackRate);\n\n            this.reconnectAudio();\n        } else {\n            console.log(\"SONG DIDN'T CHANGE\");\n        }\n\n        if (this.state.audioCtx.state !== 'suspended') {\n            if (this.props.play !== this.waveform.isPlaying()) {\n                if (!this.props.play) {\n                    console.log(\"~~~ SHOULD BE PAUSED NGL ~~~\");\n                    this.waveform.pause();\n                } else {\n                    this.playPause();\n                }\n            }\n        }\n\n        if (!this.props.shouldSync) this.synced = true; // If this is the main track, don't sync it\n\n        // If the offset between tracks is under 0.1 seconds and this is playing, this track is succesful\n        // ! The margin of error of 0.1s is needed due to timing issues with WebAudio\n        if (Math.abs(this.props.offset) < 0.1 && this.waveform.isPlaying()) {\n            this.numSuccessful++;\n            if (Math.abs(this.props.offset) < 0.05) this.numSuccessful++;\n            if (this.numSuccessful >= 3) {\n                this.synced = true;\n            }\n        }\n\n        /**\n         * IF:\n         *  1) New offset passed in\n         *  2) It has been over 5 seconds since the last time it was adjusted\n         */\n        if (this.props.offset !== prevProps.offset &&\n            this.waveform.getCurrentTime() - this.lastAdjustTime > 5 &&\n            Math.abs(this.props.offset) >= 0.05 &&\n            !this.synced) {\n            this.numSuccessful = 0;\n            console.log(this.props.deckName, \"-> about to sync\");\n            if (this.waveform.getCurrentTime() + this.props.offset > 1 && this.props.offset != 0) {\n                this.lastAdjustTime = this.waveform.getCurrentTime();\n                let adjustedOffset = this.props.offset;\n                this.totalOffset = this.props.offset;\n                console.log(\"%%%   \", this.props.deckName, \"total offset:\", this.totalOffset);\n                let desiredTime = this.waveform.getCurrentTime() + this.props.offset;\n                console.log(\"%%%   \", this.props.deckName, \" song pos was at:\", this.waveform.getCurrentTime(), \"we need:\", desiredTime);\n                this.waveform.pause();\n                this.waveform.skip(adjustedOffset);\n                this.waveform.playPause();\n                console.log(\"%%%   \", this.props.deckName, \" now we are at:\", this.waveform.getCurrentTime(), \"difference is:\", desiredTime - this.waveform.getCurrentTime(), \"offset diff:\", (this.props.offset - desiredTime - this.waveform.getCurrentTime()));\n            } else {\n                console.log(this.props.deckName, \"-> didn't sync \");\n            }\n        }\n    }\n\n    reconnectAudio() {\n        // this.state.audi1oElement.crossOrigin = \"anonymous\";\n        console.log(\"reconnecting audio\");\n        // LOWPASS\n        let lowpass = this.waveform.backend.ac.createBiquadFilter();\n        lowpass.frequency.value = this.state.audioSettings.lowpassF || 11000;\n        lowpass.type = \"lowpass\";\n        lowpass.Q.value = 5;\n        this.setState({\n            lowpassNode: lowpass\n        });\n\n        // HIGHPASS\n        let highpass = this.waveform.backend.ac.createBiquadFilter();\n        highpass.frequency.value = this.state.audioSettings.highpassF || 0;\n        highpass.type = \"highpass\";\n        highpass.Q.value = 5;\n        this.setState({\n            highpassNode: highpass\n        });\n\n        // GAIN\n        let gain = this.waveform.backend.ac.createGain();\n        gain.value = this.state.audioSettings.gain || 0.01;\n        this.setState({\n            gainNode: gain\n        });\n        this.waveform.backend.setFilter(lowpass, highpass);\n\n        if (this.props.songAnalysis !== 'NOTFOUND') {\n            let analyzed = this.props.songAnalysis.analyzed.songSections;\n            \n            analyzed.forEach(section => {\n                let region = {\n                    start: section.begin,\n                    end: section.endpoint,\n                    attributes: section.computed,\n                    data: section,\n                    color: section.sectionColor,\n                    drag: false,\n                    resize: false,\n                }\n                this.waveform.addRegion(region);\n            })\n\n            let bars = this.props.songAnalysis.analyzed.bars;\n\n            bars.forEach(b => {\n                this.waveform.addRegion(b);\n            })\n            this.setState({\n                startingPos: this.props.songAnalysis.analyzed.startPos\n            })\n        }\n        this.waveform.on('region-in', e => {\n            this.props.hitBar();\n            if (e.data.sectionType !== undefined) { // has data!\n                if (e.data.sectionType === SectionType.DROP) {\n                    this.numDropsPassed++;\n                }\n            }\n        })\n\n        this.waveform.on('region-out', e => {\n            let thisSection = e.data;\n            let computed = thisSection.computed;\n            if (computed) {\n                this.setState({\n                    currSec: thisSection.sectionType,\n                    currSectionAnalysis: {\n                        begin: thisSection.begin,\n                        endpoint: thisSection.endpoint,\n                        comparisonLoudness: computed.comparisonLoudness,\n                        differential: computed.differential,\n                        sectionConfidence: computed.sectionConfidence,\n                        conformedBegin: computed.comformedBegin,\n                        conformedEnd: computed.comformedEnd,\n                        oBegin: computed.oBegin,\n                        oEnd: computed.oEnd,\n                        sectionColor: thisSection.sectionColor,\n                        goodForMix: thisSection.goodForMix,\n                        isBest: thisSection.isBest,\n                        sizeComparison: thisSection.sizeComparison,\n                        is32: thisSection.is32\n                    }\n                })\n\n                if (thisSection.sectionType === SectionType.DROP && this.numDropsPassed > 0 && this.props.otherReady) {\n                    this.props.playOtherTrack();\n                    // TODO ADD BRAIN\n                    let think = \"Fading out \" + this.props.deckName;\n                    this.props.newThought(think, thoughtType.MIX);\n                    this.fadeOutSong();\n                }\n            } else {\n                this.props.hitBar();\n            }\n        });\n\n        this.waveform.on('ready', e => {\n            console.log(\"------ READY TO GO! 1 ------\");\n            this.state.audioCtx.resume();\n            if (!this.waveform.isPlaying()) {\n                this.playPause();\n                this.props.prepared();\n            }\n            this.waveform.setVolume(0.1);\n        });\n\n        this.waveform.on('play', e => {\n            console.log(this.props.deckName, \" JUST STARTED PLAYING GONNA FADE IT IN NOW OK\");\n            this.waveform.setVolume(0.1);\n\n            let think = \"Fading in \" + this.props.deckName;\n            this.props.newThought(think, thoughtType.MIX);\n            this.fadeInSong();\n        })\n\n    }\n\n    playPause() {\n        // check if context is in suspended state (autoplay policy)\n        if (this.state.audioCtx.state === 'suspended') {\n            this.state.audioCtx.resume();\n\n        }\n        this.waveform.play(this.state.startingPos);\n        if (this.state.playing !== this.waveform.isPlaying()) {\n            this.setState({\n                playing: this.waveform.isPlaying()\n            });\n        }\n    }\n\n    changeFilter(amount) {\n        if (amount <= 14000) {\n            this.state.audioSettings.lowpassF = amount;\n            this.state.lowpassNode.frequency.value = amount;\n        } else if (amount >= 20000) {\n            let highpassAmount = amount - 20000;\n            this.state.audioSettings.highpassF = highpassAmount;\n            this.state.highpassNode.frequency.value = this.state.audioSettings.highpassF;\n        } else {\n            this.state.audioSettings.lowpassF = 30000;\n            this.state.lowpassNode.frequency.value = this.state.audioSettings.lowpassF;\n            this.state.audioSettings.highpassF = 0;\n            this.state.highpassNode.frequency.value = this.state.audioSettings.highpassF;\n        }\n    }\n\n    changeGain(amount) {\n        this.setState({\n            audioSettings: {\n                gain: (amount / 100).toPrecision(2)\n            }\n        })\n        this.waveform.setVolume((amount / 100).toPrecision(2) || 1);\n    }\n\n    handlePosChange(e) {\n        this.setState({\n            pos: e\n        });\n    }\n\n    fadeOutSong() {\n        console.log(\"fading out\");\n        this.fadingOut = true;\n        this.waveform.setVolume(lerp(this.waveform.getVolume(), 0, Math.max(this.waveform.getVolume() / 2), 0.1, this.props.deckName));\n        this.state.lowpassNode.frequency.value -= (this.state.lowpassNode.frequency.value / 10);\n        if (this.waveform.getVolume() < 0.2) this.waveform.setVolume(this.waveform.getVolume() - 0.03);\n        if (this.waveform.getVolume() > 0.001) {\n            setTimeout(() => {\n                this.fadeOutSong();\n            }, 1000);\n        } else {\n            console.log(\">>>>>>>   >>> \", this.props.deckName, \" FADED OUT_________\");\n            this.fadingOut = false;\n            this.waveform.setVolume(0);\n            this.waveform.pause();\n            this.props.finished();\n        }\n    }\n\n    fadeInSong() {\n        console.log(\"*****\", this.props.deckName, \"fading in\", this.props.recommendedVolume);\n        this.fadingIn = true;\n        console.log(this.props.recommendedVolume);\n        this.waveform.setVolume(lerp(this.waveform.getVolume(), this.props.recommendedVolume, Math.min((this.waveform.getVolume()) / 4), 0.05, this.props.deckName));\n        if (this.waveform.getVolume() < this.props.recommendedVolume - 0.1) {\n            setTimeout(() => {\n                this.fadeInSong();\n            }, 1000);\n        } else {\n            console.log(\">>>>>>>  !!!  >>> \", this.props.deckName, \" FADED IN_________!!!!\");\n            this.fadingIn = false;\n            this.waveform.setVolume(this.props.recommendedVolume);\n        }\n    }\n\n    render() {\n        return (\n            <>\n                <div className={\"deck\"}>\n                    <img src={this.props.songImage.url} alt=\"\" />\n                    <div className={\"deck-content\"}>\n                        <div className={\"deck-text\"}>\n                            {this.props.songName !== \"\" && <h2>{this.props.songName}</h2>}\n                            {this.props.songName !== \"\" && <h3>{this.props.songArtist}</h3>}\n                        </div>\n                        <div className={\"deck-text\"}>\n                            <h4>{this.props.bpm} BPM</h4>\n                            {/* <h4>{this.props.bpm} BPM</h4> */}\n                        </div>\n                        <div id={`${this.props.waveformID}`} />\n                    </div>\n                    {/* <Knob size={70} numTicks={70} degrees={260} min={0} max={100} value={50} color={true} onChange={this.changeGain} />\n                    <label>GAIN</label>\n                    <Knob size={70} numTicks={70} degrees={260} min={1000} max={30000} value={15000} color={true} onChange={this.changeFilter} />\n                    <label>FILTER</label> */}\n                    {/* <button className={\"playButton\"} onClick={() => { this.playPause() }}>{this.state.playing ? \"Pause\" : \"Play\"}</button> */}\n                </div>\n            </>\n        );\n    }\n}\n\nfunction lerp(start, end, amt, deckname) {\n    console.log(deckname, \"lerped this:\", start, end, amt, \"to:\", (1 - amt) * start + amt * end);\n    return (1 - amt) * start + amt * end\n}\n\n","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Knob.js",[],"/Users/parssa/Desktop/repos/mixbot/src/api/keys.js",["138","139","140"],"const youtubeKey1 = \"AIzaSyC6F5gJnOX3mS2dl5-b_82PQ2ow7Xikuw8\"; // NotMixBot\n\nconst youtubeKey2 = \"AIzaSyCt7QrJ3-iInh6822WGi3Igo8J9gpH2WyA\"; // ThirdBot\n\nconst youtubeKey3 = \"AIzaSyBpT_RmX3P3wp_OMxiJT0SZIhkqFwMfVrA\"; // not set up yet\n\nconst youtubeKey4 = \"AIzaSyDgc98evXaE_C01NhK6ls2n7ZDkR - vg6sU\"; // backupPlan\n\n\nexport const currentKey = youtubeKey4;",["141","142"],"/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Queue.js",[],"/Users/parssa/Desktop/repos/mixbot/src/Mixbot.js",["143","144"],"import React, {useState} from 'react';\nimport TrackSelector from \"./TrackSelector\";\nimport TrackPlayer from \"./TrackPlayer\";\nimport QueueBox from \"./frontend_components/Queue\";\nimport Brain from \"./Brain\";\nimport { Analyzer } from './helper_classes/Analyzer';\nimport axios from 'axios';\n\nlet tracklist = [];\nlet upcomingSongs = [];\nlet alreadyPlayed = [];\n\nconst baseURL = 'http://localhost:8080';\nconst addSongRefURL = baseURL+'/addSongRef'\n\n// --- Global Functions ---\nexport function trackAlreadyIn(trackName) {\n    console.log(\"checking if track is already in....\", trackName);\n    for (const trackObj of tracklist) {\n        console.log(trackObj.songName)\n        if (trackObj.songName === trackName)\n            return true;\n    }\n    return false;\n}\n\nexport function loadTrack() {\n    let nextSong = null;\n    if (upcomingSongs.length !== 0) {\n        nextSong = upcomingSongs[0].body;\n        alreadyPlayed.push(nextSong);\n        upcomingSongs.shift();\n    }\n    return nextSong;\n}\n\nexport function nextSongInQueue() {\n    return upcomingSongs[0] || null;\n}\n\nexport function tracklistSize() {\n    return tracklist.length;\n}\n\nexport const thoughtType = {\n    NEUTRAL: 1,\n    SUCCESS: 2,\n    FAILURE: 3,\n    MIX: 4\n}\n\nexport default function Mixbot() {\n    const [thoughts, setThoughts] = useState([]);\n\n    function newThought(input, type=thoughtType.NEUTRAL) {\n        // console.log(\"1. new thought added\", input);\n        let shouldShow = true;\n        if (thoughts.length > 0 && thoughts[thoughts.length - 1].body === input) {\n            shouldShow = false;\n        }\n        setThoughts([...thoughts, { id: \"THOUGHT-\" + thoughts.length, body: input, type: type, display: shouldShow}]);\n        // console.log(\"2. new thought added\", thoughts);\n    }\n\n    /**\n     * \n     * @param {*} songName: name of song\n     * @param {*} songArtists : array of artists of song\n     * @param {*} duration_ms: duration in ms \n     * @param {*} songURL: url to the temp reference link \n     * @param {*} analysis: raw spotify analysis \n     * @param {*} trackImage: img of album art \n     * @param {*} songID:  ID OF THE SPOTIFY SONG\n     * @param {*} videoID:  ID OF THE CORRESPONDING YT LINK\n     */\n    async function addToQueue(songName, songArtists, duration_ms, songURL, analysis, trackImage, songID, videoID) {\n\n        // TODO MAKE THIS ONLY HAPPEN IF NOT FOUND IN DATABASE\n        if (analysis !== \"NOTFOUND\") {\n            let songData = analysis.data;\n\n            let analyzer = new Analyzer();\n            let analyzedData = analyzer.analyzeSong(songData);\n\n            analysis = {\n                data: songData,\n                analyzed: analyzedData\n            };\n\n            let correctedArtists = [];\n            songArtists.forEach(artist => {\n                let artistData = {\n                    artistName: artist.name,\n                    artistID: artist.id\n                }\n                correctedArtists.push(artistData);\n            })\n\n            let songRefEntry = {\n                songID: songID, // spotify id\n                videoID: videoID, // youtube videoID\n                name: songName, \n                artists: correctedArtists,\n                duration: duration_ms,\n            }\n            console.log(\"about to add song ref...\");\n            addSongRefDB(songRefEntry);\n            console.log(\"-passed that part...\");\n            // Add it to the DB\n            // let databaseEntry = {\n                // songID: songID,\n                // songName: songName,\n                // songURL: songURL,\n                // analyzed: analyzedData,\n            // }\n\n            // addTrackAnalysisDB(databaseEntry);\n\n        } \n\n        const newSong = {\n            songName: songName,\n            songArtists: songArtists,\n            duration_ms: duration_ms,\n            songURL: songURL,\n            songAnalysis: analysis,\n            trackImage: trackImage\n        }\n        console.log(\">>>(MIXBOT): NEW SONG IS:\",newSong);\n        console.log(\">>>(MIXBOT): ANALYSIS:\",analysis);\n        let packageSong = { id: \"tracklist\" + tracklist.length, body: newSong }\n        console.log(\">>>(MIXBOT): PACKAGED SONG:\", packageSong);\n        tracklist.push(packageSong);\n        console.log(\">>>(MIXBOT): ADDED TO TRACKLIST:\", tracklist);\n        upcomingSongs.push(packageSong);\n        console.log(\">>>(MIXBOT): ADDED TO UPCOMING SONGS:\", upcomingSongs);\n        const think = `Added ${songName} to the tracklist`;\n        console.log(\">>>(MIXBOT): ABOUT TO THINK:\", think);\n        newThought(think, thoughtType.NEUTRAL);\n    }\n\n    function addTrackAnalysisDB(entry) {\n        axios.create({\n            baseURL: 'http://localhost:8080',\n            headers: {}\n        }).get('/addAnalysis', {\n            params: {\n                data: entry\n            },\n        })\n    }\n\n    function addSongRefDB(entry) {\n        axios.get(addSongRefURL, {\n            params:\n            {\n                data: entry\n            }\n        });\n\n        // axios.put({\n        //     baseURL: 'http://localhost:8080',\n        //     headers: {}\n        // }).get('/addSongRef', {\n        //     params: {\n        //         track: entry\n        //     },\n        // })\n        // axios.create({\n        //     baseURL: 'http://localhost:8080',\n        //     headers: {}\n        // }).get('/addSongRef', {\n        //     params: {\n        //         track: entry\n        //     },\n        // })\n    }\n\n\n    return (\n        <>\n            <TrackPlayer newThought={newThought} />\n            <div className=\"mixbot-dropdowns\">\n                <Brain decisions={thoughts} />\n                {tracklist.length == 0 ? null : <QueueBox items={tracklist} />}\n            </div>\n            <TrackSelector addToQueue={addToQueue}/>\n        </>\n    )\n}\n","/Users/parssa/Desktop/repos/mixbot/src/Brain.js",[],"/Users/parssa/Desktop/repos/mixbot/src/helper_classes/Analyzer.js",["145","146","147","148","149","150"],"export const SectionType = {\n    DROP: 1,\n    REGULAR: 2,\n    COMEDOWN: 3,\n    BEGIN: 4,\n    UNSURE: 5\n}\n\nexport class Analyzer {\n    constructor() {\n        console.log(\"new analyzer created\");\n    }\n\n    /**\n     * Returns:\n     * {\n     *     songSections: All sections of the song, tagged with what they are\n            bars: Bars estimated through the data, used for syncing\n            startPos: Section the song should start\n     * }\n     */\n    analyzeSong(songData) {\n        console.log(\"analyzing data.\");\n        let analyzedBars = [];\n        let sectionArray = songData.sections;\n        let baselineLoudness = songData.track.loudness;\n        let allBars = songData.bars;\n        \n\n        let songSections = [];\n        let currSection = 0;\n\n        // song analysis variables\n        // let numDrops = 0;\n        // let mostConfidentDrop = 0;\n\n        // let numComedowns = 0;\n        // let mostConfidentComedown = 0;\n\n        // get an array of when all bars start\n        let barStartArray = []\n\n        let bar = allBars[0].duration;\n        let barConfidence = 0;\n        allBars.forEach(e => {\n            if (e.confidence > barConfidence) {\n                bar = e.duration;\n                barConfidence = e.confidence;\n            }\n        })\n        let barlength32 = bar * 2;\n        let songDuration = songData.track.duration;\n\n        let num32Bar = ((songDuration) / barlength32);\n\n        for (let a = 0; a <= num32Bar; a++) {\n            barStartArray.push(((a) * barlength32));\n        }\n\n        let calibrationArray = [];\n\n        let numCalibrationChunks = (songDuration) / bar;\n\n        for (let c = 0; c <= numCalibrationChunks; c++) {\n            calibrationArray.push(((c) * bar));\n        }\n\n\n        for (let b = 0; b < calibrationArray.length - 1; b++) {\n            // let barColor = (b % 2 ? \"rgba(255, 60, 54,0.05)\" : \"rgba(46, 255, 154,0.05)\");\n            let barRegion = {\n                start: calibrationArray[b],\n                end: calibrationArray[b + 1],\n                // color: barColor,\n                drag: false,\n                resize: false,\n                computed: {}\n            };\n            analyzedBars.push(barRegion); \n            // this.waveform.addRegion(barRegion);\n        }\n\n        sectionArray.forEach(e => {\n            currSection++;\n            let sectionType = SectionType.REGULAR;\n            let is32length = false;\n\n            let comparisonLoudness = (e.loudness - baselineLoudness) / baselineLoudness;\n\n            // IF BEGINNING OF SONG\n            if (songSections.length === 0) {\n                sectionType = SectionType.BEGIN;\n            }\n\n            // IF LOUD === DROP\n            if (comparisonLoudness < 0) {\n                sectionType = SectionType.DROP;\n            }\n\n            // IF LAST SONG WAS DROP AND DIFFERENTIAL OF THIS IS NEGATIVE === COMEDOWN\n            let diff = 0;\n            if (songSections.length > 0) {\n                diff = songSections[songSections.length - 1].computed.comparisonLoudness - comparisonLoudness;\n                if (songSections[songSections.length - 1].sectionType === SectionType.DROP) {\n                    if (sectionType === SectionType.DROP) {\n                        sectionType = SectionType.UNSURE;\n                    } else {\n                        sectionType = SectionType.COMEDOWN\n                    }\n                }\n            }\n\n            let beginpoint = e.start;\n            let endpoint = e.start + e.duration;\n            let closestEnd = this.closest(endpoint, barStartArray);\n            let closestBegin = this.closest(beginpoint, barStartArray);\n            let offsetBegin = closestBegin - beginpoint;\n            let offsetEnd = closestEnd - endpoint;\n            let acceptedConformEnd = false;\n            let acceptedConformBegin = false;\n\n            beginpoint = closestBegin;\n            endpoint = closestEnd;\n\n\n            let sizeComparison = ((endpoint - beginpoint) / barlength32).toPrecision(2); // checks if section is of calculated 32bar length\n            if (sizeComparison % 1) {\n                is32length = true;\n            }\n\n            let randomColor = 'rgba(162,254,231,0.3)';\n            switch (sectionType) {\n                case \"\":\n                    break;\n                case SectionType.BEGIN:\n                    // toLoop = true;\n                    randomColor = 'rgba(50,255,155,0.3)';\n                    if (is32length) {\n                        randomColor = 'rgba(100,255,55,0.3)';\n                    }\n                    break;\n                case SectionType.DROP:\n                    randomColor = 'rgba(237,61,155,0.3)';\n                    if (is32length) {\n                        randomColor = 'rgba(255,31,105,0.3)';\n                    }\n                    break;\n                case SectionType.COMEDOWN:\n                    randomColor = 'rgba(123,215,255,0.3)'\n                    if (is32length) {\n                        randomColor = 'rgba(50,150,255,0.3)'\n                    }\n                    break;\n                case SectionType.UNSURE:\n                    randomColor = 'rgba(34,1,255,0.2)'\n                    if (is32length) {\n                        randomColor = 'rgba(0,255,150,0.2)'\n                    }\n                    break;\n                default:\n                    break;\n            }\n\n            let goodForMix = false;\n            if (sectionType !== SectionType.DROP) {\n                if (comparisonLoudness > 0 && comparisonLoudness < 0.1) {\n                    randomColor = 'rgba(218, 165, 32,0.3)';\n                    goodForMix = true;\n                } else if (sectionType === SectionType.BEGIN) {\n                    randomColor = 'rgba(218, 165, 32,0.3)';\n                    goodForMix = true;\n                }\n            }\n            // ! THIS IS FOR UI PURPOSES REMOVE THIS WHEN TESTING\n            randomColor = 'rgba(0, 0, 0, 0)';\n\n            let analysisSection = {\n                sectionType: sectionType,\n                begin: beginpoint,\n                endpoint: endpoint,\n                computed: {\n                    comparisonLoudness: comparisonLoudness,\n                    differential: diff,\n                    sectionConfidence: e.confidence,\n                    conformedBegin: acceptedConformBegin,\n                    conformedEnd: acceptedConformEnd,\n                    oBegin: offsetBegin,\n                    oEnd: offsetEnd\n                },\n                sizeComparison: sizeComparison,\n                is32: is32length,\n                sectionColor: randomColor,\n                goodForMix: goodForMix\n            }\n            songSections.push(analysisSection);\n        })\n\n        let startingPos = 0; // TODO PASS THIS OUT\n\n        if (songSections.length > 2) {\n            // console.log(\"sec1:\", songSections[0].sizeComparison, \"sec2:\", songSections[1].sizeComparison);\n            // console.log(\"sec1:\", songSections[0].is32, \"sec2:\", songSections[1].is32);\n            if ((songSections[0].sizeComparison == 4) || (songSections[0].sizeComparison == 2 && songSections[1].sizeComparison == 2)) {\n                    startingPos= 0\n            } else if (songSections[0].sizeComparison == 2.0 && songSections[1].sizeComparison % 4 == 0) { // todo make this if songSections[1].sizeComparison is a multiple of 4\n                // console.log(\"mult of 4?\", songSections[1].sizeComparison % 4);\n                startingPos = songSections[0].endpoint;  \n            } \n        }\n\n        let finalAnalysis = {\n            songSections: songSections,\n            bars: calibrationArray,\n            startPos: startingPos\n        }\n\n        return finalAnalysis;\n    }\n\n\n    closest(needle, haystack) {\n        let closeGrain = 100000000000000;\n        let grainCloseness = 100000000000000;\n        haystack.forEach(grain => {\n            let thisCloseness = Math.abs(needle - grain)\n            if (Math.abs(needle - grain) < grainCloseness) {\n                grainCloseness = thisCloseness;\n                closeGrain = grain;\n            }\n        })\n        return closeGrain;\n    }\n}",{"ruleId":"151","replacedBy":"152"},{"ruleId":"153","replacedBy":"154"},{"ruleId":"155","severity":1,"message":"156","line":1,"column":16,"nodeType":"157","messageId":"158","endLine":1,"endColumn":24},{"ruleId":"155","severity":1,"message":"159","line":1,"column":26,"nodeType":"157","messageId":"158","endLine":1,"endColumn":35},{"ruleId":"155","severity":1,"message":"160","line":5,"column":8,"nodeType":"157","messageId":"158","endLine":5,"endColumn":13},{"ruleId":"155","severity":1,"message":"161","line":2,"column":8,"nodeType":"157","messageId":"158","endLine":2,"endColumn":16},{"ruleId":"155","severity":1,"message":"162","line":6,"column":8,"nodeType":"157","messageId":"158","endLine":6,"endColumn":14},{"ruleId":"155","severity":1,"message":"163","line":8,"column":10,"nodeType":"157","messageId":"158","endLine":8,"endColumn":25},{"ruleId":"155","severity":1,"message":"164","line":8,"column":27,"nodeType":"157","messageId":"158","endLine":8,"endColumn":38},{"ruleId":"155","severity":1,"message":"165","line":48,"column":14,"nodeType":"157","messageId":"158","endLine":48,"endColumn":26},{"ruleId":"155","severity":1,"message":"166","line":65,"column":14,"nodeType":"157","messageId":"158","endLine":65,"endColumn":29},{"ruleId":"155","severity":1,"message":"167","line":1,"column":8,"nodeType":"157","messageId":"158","endLine":1,"endColumn":13},{"ruleId":"155","severity":1,"message":"168","line":4,"column":17,"nodeType":"157","messageId":"158","endLine":4,"endColumn":20},{"ruleId":"155","severity":1,"message":"169","line":4,"column":33,"nodeType":"157","messageId":"158","endLine":4,"endColumn":40},{"ruleId":"170","severity":1,"message":"171","line":102,"column":8,"nodeType":"172","endLine":102,"endColumn":23,"suggestions":"173"},{"ruleId":"170","severity":1,"message":"174","line":104,"column":15,"nodeType":"175","endLine":111,"endColumn":6},{"ruleId":"170","severity":1,"message":"176","line":111,"column":8,"nodeType":"172","endLine":111,"endColumn":36,"suggestions":"177"},{"ruleId":"155","severity":1,"message":"178","line":1,"column":7,"nodeType":"157","messageId":"158","endLine":1,"endColumn":12},{"ruleId":"155","severity":1,"message":"164","line":4,"column":38,"nodeType":"157","messageId":"158","endLine":4,"endColumn":49},{"ruleId":"170","severity":1,"message":"179","line":39,"column":5,"nodeType":"157","endLine":39,"endColumn":14,"suggestions":"180"},{"ruleId":"181","severity":1,"message":"182","line":50,"column":27,"nodeType":"183","messageId":"184","endLine":50,"endColumn":29},{"ruleId":"181","severity":1,"message":"182","line":50,"column":47,"nodeType":"183","messageId":"184","endLine":50,"endColumn":49},{"ruleId":"181","severity":1,"message":"182","line":53,"column":34,"nodeType":"183","messageId":"184","endLine":53,"endColumn":36},{"ruleId":"181","severity":1,"message":"182","line":53,"column":54,"nodeType":"183","messageId":"184","endLine":53,"endColumn":56},{"ruleId":"155","severity":1,"message":"156","line":1,"column":16,"nodeType":"157","messageId":"158","endLine":1,"endColumn":24},{"ruleId":"155","severity":1,"message":"185","line":9,"column":12,"nodeType":"157","messageId":"158","endLine":9,"endColumn":19},{"ruleId":"170","severity":1,"message":"186","line":50,"column":8,"nodeType":"172","endLine":50,"endColumn":13,"suggestions":"187"},{"ruleId":"170","severity":1,"message":"188","line":66,"column":8,"nodeType":"172","endLine":66,"endColumn":19,"suggestions":"189"},{"ruleId":"151","replacedBy":"190"},{"ruleId":"153","replacedBy":"191"},{"ruleId":"155","severity":1,"message":"192","line":2,"column":8,"nodeType":"157","messageId":"158","endLine":2,"endColumn":12},{"ruleId":"155","severity":1,"message":"193","line":98,"column":13,"nodeType":"157","messageId":"158","endLine":98,"endColumn":18},{"ruleId":"181","severity":1,"message":"194","line":186,"column":93,"nodeType":"183","messageId":"184","endLine":186,"endColumn":95},{"ruleId":"195","severity":1,"message":"196","line":339,"column":13,"nodeType":"197","endLine":339,"endColumn":37},{"ruleId":"195","severity":1,"message":"196","line":340,"column":13,"nodeType":"197","endLine":340,"endColumn":45},{"ruleId":"195","severity":1,"message":"196","line":343,"column":13,"nodeType":"197","endLine":343,"endColumn":37},{"ruleId":"195","severity":1,"message":"196","line":344,"column":13,"nodeType":"197","endLine":344,"endColumn":46},{"ruleId":"195","severity":1,"message":"196","line":346,"column":13,"nodeType":"197","endLine":346,"endColumn":37},{"ruleId":"195","severity":1,"message":"196","line":347,"column":13,"nodeType":"197","endLine":347,"endColumn":45},{"ruleId":"195","severity":1,"message":"196","line":348,"column":13,"nodeType":"197","endLine":348,"endColumn":37},{"ruleId":"195","severity":1,"message":"196","line":349,"column":13,"nodeType":"197","endLine":349,"endColumn":46},{"ruleId":"195","severity":1,"message":"196","line":372,"column":9,"nodeType":"197","endLine":372,"endColumn":41},{"ruleId":"155","severity":1,"message":"198","line":1,"column":7,"nodeType":"157","messageId":"158","endLine":1,"endColumn":18},{"ruleId":"155","severity":1,"message":"199","line":3,"column":7,"nodeType":"157","messageId":"158","endLine":3,"endColumn":18},{"ruleId":"155","severity":1,"message":"200","line":5,"column":7,"nodeType":"157","messageId":"158","endLine":5,"endColumn":18},{"ruleId":"151","replacedBy":"201"},{"ruleId":"153","replacedBy":"202"},{"ruleId":"155","severity":1,"message":"203","line":142,"column":14,"nodeType":"157","messageId":"158","endLine":142,"endColumn":32},{"ruleId":"181","severity":1,"message":"182","line":185,"column":35,"nodeType":"183","messageId":"184","endLine":185,"endColumn":37},{"ruleId":"155","severity":1,"message":"204","line":84,"column":13,"nodeType":"157","messageId":"158","endLine":84,"endColumn":24},{"ruleId":"181","severity":1,"message":"182","line":203,"column":49,"nodeType":"183","messageId":"184","endLine":203,"endColumn":51},{"ruleId":"181","severity":1,"message":"182","line":203,"column":90,"nodeType":"183","messageId":"184","endLine":203,"endColumn":92},{"ruleId":"181","severity":1,"message":"182","line":203,"column":129,"nodeType":"183","messageId":"184","endLine":203,"endColumn":131},{"ruleId":"181","severity":1,"message":"182","line":205,"column":55,"nodeType":"183","messageId":"184","endLine":205,"endColumn":57},{"ruleId":"181","severity":1,"message":"182","line":205,"column":100,"nodeType":"183","messageId":"184","endLine":205,"endColumn":102},"no-native-reassign",["205"],"no-negated-in-lhs",["206"],"no-unused-vars","'useState' is defined but never used.","Identifier","unusedVar","'useEffect' is defined but never used.","'axios' is defined but never used.","'Dropdown' is defined but never used.","'Detail' is defined but never used.","'nextSongInQueue' is defined but never used.","'thoughtType' is defined but never used.","'genreChanged' is defined but never used.","'playlistChanged' is defined but never used.","'React' is defined but never used.","'end' is defined but never used.","'pattern' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'videoIDtoMP3'. Either include it or remove the dependency array.","ArrayExpression",["207"],"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching","ArrowFunctionExpression","React Hook useEffect has missing dependencies: 'createSearchQuery' and 'getYoutubeVideo'. Either include them or remove the dependency array.",["208"],"'cred1' is assigned a value but never used.","React Hook useEffect contains a call to 'setClock'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [clock] as a second argument to the useEffect Hook.",["209"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'playing' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'volume'. Either include it or remove the dependency array. You can also do a functional update 'setVolume(v => ...)' if you only need 'volume' in the 'setVolume' call.",["210"],"React Hook useEffect has a missing dependency: 'handlePlayPause'. Either include it or remove the dependency array.",["211"],["205"],["206"],"'Knob' is defined but never used.","'dummy' is assigned a value but never used.","Expected '!==' and instead saw '!='.","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","'youtubeKey1' is assigned a value but never used.","'youtubeKey2' is assigned a value but never used.","'youtubeKey3' is assigned a value but never used.",["205"],["206"],"'addTrackAnalysisDB' is defined but never used.","'currSection' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"212","fix":"213"},{"desc":"214","fix":"215"},{"desc":"216","fix":"217"},{"desc":"218","fix":"219"},{"desc":"220","fix":"221"},"Update the dependencies array to be: [chosenVideoID, videoIDtoMP3]",{"range":"222","text":"223"},"Update the dependencies array to be: [name, artists, duration_ms, createSearchQuery, getYoutubeVideo]",{"range":"224","text":"225"},"Add dependencies array: [clock]",{"range":"226","text":"227"},"Update the dependencies array to be: [url, volume]",{"range":"228","text":"229"},"Update the dependencies array to be: [handlePlayPause, isPlaying]",{"range":"230","text":"231"},[3772,3787],"[chosenVideoID, videoIDtoMP3]",[4065,4093],"[name, artists, duration_ms, createSearchQuery, getYoutubeVideo]",[1369,1369],", [clock]",[1849,1854],"[url, volume]",[2436,2447],"[handlePlayPause, isPlaying]"]