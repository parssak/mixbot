[{"/Users/parssa/Desktop/repos/mixbot/src/index.js":"1","/Users/parssa/Desktop/repos/mixbot/src/App.js":"2","/Users/parssa/Desktop/repos/mixbot/src/reportWebVitals.js":"3","/Users/parssa/Desktop/repos/mixbot/src/TrackSelector.js":"4","/Users/parssa/Desktop/repos/mixbot/src/TrackFinder.js":"5","/Users/parssa/Desktop/repos/mixbot/src/Credentials.js":"6","/Users/parssa/Desktop/repos/mixbot/src/TrackPlayer.js":"7","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Detail.js":"8","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Listbox.js":"9","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Dropdown.js":"10","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Waveform.js":"11","/Users/parssa/Desktop/repos/mixbot/src/api/youtubeVideoContent.js":"12","/Users/parssa/Desktop/repos/mixbot/src/api/youtube.js":"13","/Users/parssa/Desktop/repos/mixbot/src/Deck.js":"14","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Knob.js":"15"},{"size":500,"mtime":1609255907946,"results":"16","hashOfConfig":"17"},{"size":492,"mtime":1610168291738,"results":"18","hashOfConfig":"17"},{"size":362,"mtime":1609255907947,"results":"19","hashOfConfig":"17"},{"size":6127,"mtime":1610150765998,"results":"20","hashOfConfig":"17"},{"size":4553,"mtime":1610148996823,"results":"21","hashOfConfig":"17"},{"size":182,"mtime":1609255907943,"results":"22","hashOfConfig":"17"},{"size":11740,"mtime":1610206081698,"results":"23","hashOfConfig":"17"},{"size":570,"mtime":1609255907945,"results":"24","hashOfConfig":"17"},{"size":784,"mtime":1610146514577,"results":"25","hashOfConfig":"17"},{"size":550,"mtime":1609255907945,"results":"26","hashOfConfig":"17"},{"size":3782,"mtime":1609255907946,"results":"27","hashOfConfig":"17"},{"size":676,"mtime":1610154367753,"results":"28","hashOfConfig":"17"},{"size":690,"mtime":1610154363506,"results":"29","hashOfConfig":"17"},{"size":28721,"mtime":1610154113453,"results":"30","hashOfConfig":"17"},{"size":4780,"mtime":1609255907945,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},"11p3aqi",{"filePath":"35","messages":"36","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"34"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"34"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"34"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"34"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"60"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":28,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"34"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},"/Users/parssa/Desktop/repos/mixbot/src/index.js",[],["71","72"],"/Users/parssa/Desktop/repos/mixbot/src/App.js",["73","74"],"import React, {useState, useEffect} from 'react';\nimport './css_files/App.css';\nimport TrackSelector from \"./TrackSelector\";\n\nfunction App() {\n    return(\n        <div className={\"body\"}>\n            <div className={\"title\"}>\n                <h1>MIXBOT</h1>\n                 <div className={\"credits\"}>\n                    <h3>An Open Source project by Parssa Kyanzadeh</h3> \n                 </div>\n            </div>\n            <TrackSelector/>\n        </div>\n    );\n}\nexport default App;\n","/Users/parssa/Desktop/repos/mixbot/src/reportWebVitals.js",[],"/Users/parssa/Desktop/repos/mixbot/src/TrackSelector.js",["75","76","77","78"],"import React, { useState, useEffect } from 'react';\nimport Dropdown from \"./frontend_components/Dropdown\";\nimport { Credentials } from './Credentials';\nimport axios from 'axios';\nimport Listbox from \"./frontend_components/Listbox\";\nimport Detail from \"./frontend_components/Detail\";\nimport TrackFinder from \"./TrackFinder\";\nimport TrackPlayer, { trackAlreadyIn, addToQueue } from \"./TrackPlayer\";\n\nconst euroHouseID = \"2818tC1Ba59cftJJqjWKZi\";\n\nfunction TrackSelector() {\n    const spotify = Credentials();\n    const [token, setToken] = useState('');\n    const [genres, setGenres] = useState({ selectedGenre: '', listOfGenresFromAPI: [] });\n    const [playlist, setPlaylist] = useState({ selectedPlaylist: '2818tC1Ba59cftJJqjWKZi', listOfPlaylistFromAPI: [] });\n    const [tracks, setTracks] = useState({ selectedTrack: '', listOfTracksFromAPI: [] });\n    const [trackDetail, setTrackDetail] = useState(null);\n\n    useEffect(() => {\n        axios('https://accounts.spotify.com/api/token', {\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                'Authorization': 'Basic ' + btoa(spotify.ClientId + ':' + spotify.ClientSecret)\n            },\n            data: 'grant_type=client_credentials',\n            method: 'POST'\n        })\n            .then(tokenResponse => {\n                setToken(tokenResponse.data.access_token);\n                // axios('https://api.spotify.com/v1/browse/categories', {\n                //     method: 'GET',\n                //     headers: { 'Authorization' : 'Bearer ' + tokenResponse.data.access_token}\n                // })\n                //     .then (genreResponse => {\n                //         console.log(genreResponse)\n                //         setGenres({\n                //             selectedGenre: genres.selectedGenre,\n                //             listOfGenresFromAPI: genreResponse.data.categories.items\n                //         })\n                //     });\n\n            });\n\n    }, [genres.selectedGenre, spotify.ClientId, spotify.ClientSecret]);\n\n    function genreChanged(val) {\n        setGenres({\n            selectedGenre: val,\n            listOfGenresFromAPI: genres.listOfGenresFromAPI\n        });\n\n        axios(`https://api.spotify.com/v1/browse/categories/${val}/playlists?limit=30`, {\n            method: 'GET',\n            headers: { 'Authorization': 'Bearer ' + token }\n        }).then(playlistResponse => {\n            setPlaylist({\n                selectedPlaylist: playlist.selectedPlaylist,\n                listOfPlaylistFromAPI: playlistResponse.data.playlists.items\n            })\n        });\n    }\n\n    function playlistChanged(val) {\n        setPlaylist({\n            selectedPlaylist: val,\n            listOfPlaylistFromAPI: playlist.listOfPlaylistFromAPI\n        });\n    }\n\n    function playlistSearchClicked(e) {\n        e.preventDefault();\n        console.log(\"selected playlist was\" + playlist.selectedPlaylist);\n        axios(`https://api.spotify.com/v1/playlists/${playlist.selectedPlaylist}/tracks?limit=40`, {\n            method: 'GET',\n            headers: {\n                'Authorization': 'Bearer ' + token\n            }\n        }).then(tracksResponse => {\n            setTracks({\n                selectedTrack: tracks.selectedTrack,\n                listOfTracksFromAPI: tracksResponse.data.items\n            })\n        });\n    }\n\n    function selectTrack(val) {\n        const currentTracks = [...tracks.listOfTracksFromAPI];\n        const trackInfo = currentTracks.filter(t => t.track.id === val);\n        if (!trackAlreadyIn(trackInfo[0].track.name)) {\n            console.log(\">>>\",trackInfo[0].track);\n            setTrackDetail(trackInfo[0].track);\n        } else {\n            console.log(\"track is already in the queue\");\n        }\n    }\n\n    async function addSongToTracklist(songName, songArtists, duration, songURL, trackID, trackImage) {\n        if (!trackAlreadyIn(songName)) {\n            console.log(\"adding: \" + songName + \"with id \" + trackID);\n            getAudioAnalysis(trackID, songName, songArtists, duration, songURL, trackImage);\n        } else {\n            console.log(\"track is already in the queue\");\n            setTrackDetail(null);\n        }\n    }\n\n    const getAudioAnalysis = (id, songName, songArtists, duration, songURL, trackImage) => {\n        console.log(\"song id is \" + id);\n        axios(`https://api.spotify.com/v1/audio-analysis/${id}`, {\n            method: 'GET',\n            headers: {\n                'Authorization': 'Bearer ' + token\n            }\n        }).then(e => {\n            console.log(e);\n            addToQueue(songName, songArtists, duration, songURL, e, trackImage);\n        }).catch(e => {\n            addToQueue(songName, songArtists, duration, songURL, \"NOTFOUND\", trackImage);\n            console.log(e);\n        }).finally(() => {\n            setTrackDetail(null);\n        });\n    }\n\n    return (\n        <div>\n            {/* <hr/> */}\n            <TrackPlayer />\n            {/* <hr /> */}\n            <form onSubmit={playlistSearchClicked}>\n                {/* <Dropdown label=\"Genre: \" options={genres.listOfGenresFromAPI} selectedValue={genres.selectedGenre} changed={genreChanged} /> */}\n                {/* <Dropdown label=\"Playlist: \" options={playlist.listOfPlaylistFromAPI} selectedValue={playlist.selectedPlaylist} changed={playlistChanged} /> */}\n                {playlist.selectedPlaylist !== \"\" ? <button type='submit' className=\"begin-mix\">BEGIN MIX</button> : null}\n                <div>\n                    <Listbox items={tracks.listOfTracksFromAPI} clicked={selectTrack} />\n                    {trackDetail && <Detail {...trackDetail} />}\n                    {trackDetail && <TrackFinder name={trackDetail.name}\n                        artists={trackDetail.artists}\n                        duration_ms={trackDetail.duration_ms}\n                        trackID={trackDetail.id}\n                        trackImage={trackDetail.album.images[1]}\n                        foundSong={addSongToTracklist} />}\n                </div>\n            </form>\n        </div>\n    );\n}\n\nexport default TrackSelector;\n","/Users/parssa/Desktop/repos/mixbot/src/TrackFinder.js",["79","80","81","82","83","84"],"import React, {useEffect, useState} from 'react';\nimport youtubeApi from './api/youtube'\nimport videoDetailFinder from './api/youtubeVideoContent'\nimport {parse, end, toSeconds, pattern} from 'iso8601-duration';\nimport ytdl from \"react-native-ytdl\";\n\n/**\n * This class handles finding a track based on song name, artists, and duration\n * and calls the foundSong prop when a song has been found.\n *\n * @param name: Name of the Song\n * @param artists: An array of artist objects\n * @param duration_ms: The duration of the song in milliseconds\n * @param foundSong: A prop that gets called when song has been found\n * @param trackID:\n */\nlet lastChosenID = \"\";\nexport default function TrackFinder({name, artists, duration_ms, foundSong, trackID, trackImage}) {\n\n    const [songName, setSongName] = useState(name);\n    const [songArtists, setSongArtists] = useState(artists);\n    const [duration, setDuration] = useState(duration_ms);\n    const [chosenVideoID, setChosenVideoID] = useState(\"\");\n\n    function createSearchQuery() {\n        console.log(\" -- Entered createSearchQuery -- \")\n        let artistNames = [];\n        artists.forEach(e => {\n            const thisName = e.name;\n            if (thisName) {\n                artistNames.push(thisName)\n            }\n        });\n        let searchQuery = name + \" by \" + artistNames[0];\n        console.log(\"SEARCH QUERY:\",searchQuery);\n        return searchQuery;\n    }\n\n\n    async function videosSearch(search) {\n        console.log(\"--- Entered videosSearch ---\")\n        const response = await youtubeApi.get(\"/search\", {\n            params:{\n                q:search\n            }\n        })\n        return response;\n    }\n\n    async function videoDetail(videoID) {\n        const response = await videoDetailFinder.get(\"/videos\", {\n            params:{\n                id:videoID\n            }\n        })\n        return response;\n    }\n\n    /**\n     * Searches YouTube for song using search query, breaks when found is song\n     * @param searchQuery\n     * @returns {Promise<void>}\n     */\n    async function getYoutubeVideo(searchQuery) {\n        videosSearch(searchQuery).then(async e => {\n            const videoList = e.data.items;\n            console.log(\"-- Entered getYoutubeVideo --\");\n            for (let video = 0; video < videoList.length; video++) {\n                const thisID = await videoDetail(videoList[video].id.videoId);\n                const thisDur = toMilli(thisID.data.items[0].contentDetails.duration);\n                if (Math.abs(duration - thisDur) <= 1000) {\n                    console.log(videoList[video]);\n                    setChosenVideoID(videoList[video].id.videoId);\n                    break;\n                }\n            }\n\n        }).finally(async () => {\n            if (chosenVideoID === \"\") {\n                // console.log(\"could not find song\");\n            } else {\n                // console.log(\"found song\")\n            }\n\n        })\n    }\n\n    /**\n     * Helper function for converting ISO8 8601 time to milliseconds\n     * @param ISO: ISO time\n     * @returns {the ISO time in milliseconds}\n     */\n    function toMilli(ISO) {\n        return toSeconds( parse(ISO) ) * 1000;\n    }\n\n    /**\n     * This effect triggers when the chosenVideoID is\n     * found, and then get the URL for mp3 download\n     *\n     * Since this effect gets called over once for the\n     * same video being found sometimes, it will not\n     * convert the video to mp3 if it has already been\n     * called once for this current song\n     * >> “ \"lastChosenID === \"\" ”\n     */\n    useEffect(() => {\n        console.log(\"| got youtube video ID, effect triggered | \")\n        if (chosenVideoID && lastChosenID === \"\") {\n            lastChosenID = chosenVideoID;\n            videoIDtoMP3(chosenVideoID);\n        }\n\n    }, [chosenVideoID])\n\n    useEffect(async () => {\n        console.log(\"----- entered fx\");\n        setSongArtists(artists);\n        setSongName(name);\n        setDuration(duration_ms);\n        lastChosenID = \"\";\n        const search = createSearchQuery();\n        await getYoutubeVideo(search);\n    }, [name, artists, duration_ms]);\n\n    async function videoIDtoMP3(videoID) {\n        console.log(\"-- Entered videoIDtoMP3 --\")\n        await ytdl.getInfo(videoID, { quality: 'highestaudio'}).then(info => {\n            let audioFormats = ytdl.filterFormats(info.formats, 'audioonly');\n            foundSong(songName, songArtists, duration, audioFormats[0].url, trackID, trackImage);\n            setChosenVideoID(\"\");\n        });\n    }\n\n    return null;\n}","/Users/parssa/Desktop/repos/mixbot/src/Credentials.js",[],"/Users/parssa/Desktop/repos/mixbot/src/TrackPlayer.js",["85","86","87","88","89","90","91","92"],"/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Detail.js",[],"/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Listbox.js",[],"/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Dropdown.js",["93"],"import React, {useState} from 'react';\n\nconst Dropdown = props => {\n\n    const dropdownChanged = e => {\n        props.changed(e.target.value);\n\n    }\n\n    return (\n        <div className=\"dropdown\">\n            <label>{props.label}</label>\n            <select value={props.selectedValue} onChange={dropdownChanged}>\n                <option key={0}>Select...</option>\n                {props.options.map((item, idx) => <option key={idx + 1} value={item.id}>{item.name}</option>)}\n            </select>\n        </div>\n    );\n}\n\nexport default Dropdown;\n","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Waveform.js",["94","95","96"],"import React, { useEffect, useRef, useState } from \"react\";\nimport WaveSurfer from 'wavesurfer.js';\n\n//https://codesandbox.io/s/audio-player-with-wavesurferjs-react-bd499?from-embed=&file=/src/Waveform.js:0-60\n\nexport default function Waveform({ url, onPositionChange, isPlaying, audioCtx, lowpassNum }) {\n    const waveformRef = useRef(null);\n    const wavesurfer = useRef(null);\n    const [playing, setPlay] = useState(false);\n    const [volume, setVolume] = useState(0.5);\n    const formWaveSurferOptions = ref => ({\n        container: ref,\n        waveColor: \"#beb9b9\",\n        progressColor: \"#9a68c9\",\n        cursorColor: \"#dac4f0\",\n        hideScrollbar: true,\n        responsive: true,\n        partialRender: true,\n        normalize: true,\n        height:200\n    });\n\n    // create new WaveSurfer instance\n    // On component mount and when url changes\n    useEffect(() => {\n        setPlay(false);\n\n        const options = formWaveSurferOptions(waveformRef.current);\n        wavesurfer.current = WaveSurfer.create(options);\n        wavesurfer.current.load(url.src);\n        wavesurfer.current.on(\"ready\", function() {\n            // https://wavesurfer-js.org/docs/methods.html\n            // wavesurfer.current.play();\n            // setPlay(true);\n\n            // make sure object still available when file loaded\n            if (wavesurfer.current) {\n                wavesurfer.current.setVolume(volume);\n                setVolume(volume);\n            }\n            let lowpass = wavesurfer.backend.ac.createBiquadFilter();\n            lowpass.type = \"lowpass\";\n            lowpass.frequency.value = 10;\n            wavesurfer.current.backend.setFilter(lowpass);\n        });\n\n        // Removes events, elements and disconnects Web Audio nodes.\n        // when component unmount\n        return () => wavesurfer.current.destroy();\n    }, [url]);\n\n    useEffect(() => {\n        console.log(\"!!!\")\n        handlePlayPause();\n        console.log(wavesurfer.current.getFilters());\n        // if (isPlaying !== playing) {\n        //     handlePlayPause();\n        // }\n        // wavesurfer.current.on('audioprocess', function () {\n        //     // $('.waveform__counter').text( formatTime(wavesurfer.getCurrentTime()) );\n        //     // console.log(wavesurfer.current.getCurrentTime());\n        //     // console.log(\"--\")\n        //     onPositionChange(wavesurfer.current.getCurrentTime());\n        //\n        // });\n    }, [isPlaying]);\n\n    useEffect( () => {\n        console.log(\"lowpass\", lowpassNum);\n\n    }, [lowpassNum])\n\n\n    const handlePlayPause = () => {\n        console.log(\"switching this\");\n        setPlay(isPlaying);\n        wavesurfer.current.playPause();\n    };\n\n    // const onVolumeChange = e => {\n    //     const { target } = e;\n    //     const newVolume = +target.value;\n    //\n    //     if (newVolume) {\n    //         setVolume(newVolume);\n    //         wavesurfer.current.setVolume(newVolume || 1);\n    //     }\n    // };\n\n    return (\n        <div className={\"waveform-comp\"}>\n            <div id=\"waveform\" ref={waveformRef} />\n            <div className=\"controls\">\n                {/*<button onClick={handlePlayPause}>{!playing ? \"Play\" : \"Pause\"}</button>*/}\n                {/*<input*/}\n                {/*    type=\"range\"*/}\n                {/*    id=\"volume\"*/}\n                {/*    name=\"volume\"*/}\n                {/*    // waveSurfer recognize value of `0` same as `1`*/}\n                {/*    //  so we need to set some zero-ish value for silence*/}\n                {/*    min=\"0.01\"*/}\n                {/*    max=\"1\"*/}\n                {/*    step=\".025\"*/}\n                {/*    onChange={onVolumeChange}*/}\n                {/*    defaultValue={volume}*/}\n                {/*/>*/}\n            </div>\n        </div>\n    );\n}",["97","98"],"/Users/parssa/Desktop/repos/mixbot/src/api/youtubeVideoContent.js",[],"/Users/parssa/Desktop/repos/mixbot/src/api/youtube.js",[],"/Users/parssa/Desktop/repos/mixbot/src/Deck.js",["99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126"],"import React, { Component } from 'react';\nimport Knob from './frontend_components/Knob';\nimport WaveSurfer from 'wavesurfer.js';\nimport RegionPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.regions.min.js';\n// import { end } from \"iso8601-duration\";\n\nconst tempTrack = \"https://r8---sn-cxaaj5o5q5-tt1y.googlevideo.com/videoplayback?expire=1608683629&ei=DTziX9T7BpmCir4PtcKm6AQ&ip=142.126.73.189&id=o-AMVicLbj0Gv2rQrVjovPek8wxxBV4FI5LMlCg6R1G6tz&itag=251&source=youtube&requiressl=yes&mh=rs&mm=31%2C26&mn=sn-cxaaj5o5q5-tt1y%2Csn-vgqs7nls&ms=au%2Conr&mv=m&mvi=8&pl=24&gcr=ca&initcwndbps=1700000&vprv=1&mime=audio%2Fwebm&ns=s_KJpKjwEsZZ8AheQ_gNizUF&gir=yes&clen=3788632&dur=222.601&lmt=1595575954110558&mt=1608661718&fvip=1&keepalive=yes&c=WEB&txp=2311222&n=P9s4oVIr7EC14Ztz&sparams=expire%2Cei%2Cip%2Cid%2Citag%2Csource%2Crequiressl%2Cgcr%2Cvprv%2Cmime%2Cns%2Cgir%2Cclen%2Cdur%2Clmt&lsparams=mh%2Cmm%2Cmn%2Cms%2Cmv%2Cmvi%2Cpl%2Cinitcwndbps&lsig=AG3C_xAwRAIgRMh65mjTW6PwQwyNug7n8o3U7_emmK9tyYapXeysfYACIHepjV45GMhesgNEo1wTHgBd5QnjG5icCMtM_PqjfFo_&ratebypass=yes&sig=AOq0QJ8wRgIhANl_rwVxcCYUdSw5WCiK5WWQwGPeV6RqvmXBcFXpCmlMAiEAxuwr91Yd_by6vYdEcszyTD--r58Ll8EWI6QUANVTrYk%3D\";\n// const tempTrack = \"https://www.mfiles.co.uk/mp3-downloads/franz-schubert-standchen-serenade.mp3\";\n\n\nconst DROP = 'DROP';\nconst BEGIN = 'BEGIN';\nconst COMEDOWN = 'COMEDOWN';\nconst UNSURE = 'UNSURE';\nconst REGULAR = 'REG';\n\n/**\n * TODO\n * - Set up queueing of tracks\n */\n\nlet barSize = 0;\n\nexport default class Deck extends Component {\n    constructor(props) {\n        super(props);\n        console.log(\"entered constructor call!\");\n        this.state = {\n            pos: 0,\n            locked: false,\n            scheduledDemise: false,\n            currSec: \"NOT PLAYING\",\n            playing: false,\n            trackName: this.props.songName,\n            trackArtist: this.props.songArtist,\n            audioCtx: new AudioContext(),\n            audioElement: new Audio(this.props.thisSong),\n            audioSettings: {\n                gain: 1,\n                lowpassF: 11000,\n                highpassF: 0,\n                high: 1,\n                mid: 1,\n                low: 1,\n                playbackRate: this.props.playbackRate\n            },\n            currSectionAnalysis: {\n                begin: NaN,\n                endpoint: NaN,\n                comparisonLoudness: NaN,\n                differential: NaN,\n                sectionConfidence: NaN,\n                conformedBegin: NaN,\n                conformedEnd: NaN,\n                oBegin: NaN,\n                oEnd: NaN,\n                sectionColor: `rgb(255,255,255)`,\n                goodForMix: false,\n                isBest: false\n            },\n            startingPos: 0\n        };\n        this.lastAdjustTime = 0;\n        this.synced = false;\n        this.fadingOut = false;\n        this.fadingIn = false;\n        this.totalOffset = 0;\n        this.numSuccessful = 0;\n        this.numDropsPassed = 0;\n\n\n        this.playPause = this.playPause.bind(this);\n        this.fadeOutSong = this.fadeOutSong.bind(this);\n        this.changeFilter = this.changeFilter.bind(this);\n        this.changeGain = this.changeGain.bind(this);\n        this.reconnectAudio = this.reconnectAudio.bind(this);\n        this.analyzeData = this.analyzeData.bind(this);\n        this.handlePosChange = this.handlePosChange.bind(this);\n    }\n\n    componentDidMount() {\n        console.log(\"|| ---- COMPONENT DID MOUNT ---- ||\", this.props.deckName);\n        // wavesurfer begins here\n        this.waveform = WaveSurfer.create({\n            container: '#waveform',\n            waveColor: \"#ffffff\",\n            cursorColor: \"#dac4f0\",\n            hideScrollbar: true,\n            normalize: false,\n            height: 100,\n            plugins: [\n                RegionPlugin.create(),\n            ]\n        });\n\n\n        this.waveform.load(this.state.audioElement.src);\n        this.waveform.setPlaybackRate(this.props.playbackRate);\n        this.reconnectAudio();\n    }\n\n    componentDidUpdate(prevProps) {\n        console.log(\"||| ---- COMPONENT DID UPDATE ---- |||\", this.props.deckName);\n        console.log(\"TRACK IMG:\", this.props.songImage)\n        if (this.props.thisSong !== prevProps.thisSong) { // TODO LEFT OFF HERE, YOU WERE TRYING TO MAKE SWITCHING SONGS ON A SINGLE DECK WORK BC IT KEEPS PLAYING THE OLD ONE ALSO REGIONS AREN\"T DISAPPEARING\n            console.log(\"|| -- THE SONG CHANGED -- ||\", this.props.deckName);\n            this.waveform.pause();\n\n            this.synced = false;\n            this.numSuccessful = 0;\n            this.totalOffset = 0;\n            this.fadingOut = false;\n            this.fadingIn = false;\n            this.numDropsPassed = 0;\n\n            this.waveform.destroy();\n            this.waveform = WaveSurfer.create({\n                container: '#waveform',\n                waveColor: \"#ffffff\",\n                cursorColor: \"#dac4f0\",\n                hideScrollbar: true,\n                normalize: false,\n                height: 100,\n                plugins: [\n                    RegionPlugin.create(),\n                ]\n            });\n\n            this.state.audioElement.load();\n            this.state.audioElement = new Audio(this.props.thisSong);\n            // this.state.audioElement.src = this.props.thisSong;\n\n            this.waveform.load(this.state.audioElement.src);\n            this.waveform.setPlaybackRate(this.props.playbackRate);\n\n            this.reconnectAudio();\n        }\n\n        if (this.state.audioCtx.state !== 'suspended') {\n            if (this.props.play !== this.waveform.isPlaying()) {\n                if (!this.props.play) {\n                    console.log(\"~~~ SHOULD BE PAUSED NGL ~~~\");\n                    // this.waveform.stop();\n                    this.waveform.pause(); // todo testing this swap\n                } else {\n                    this.playPause();\n                }\n            }\n        }\n        if (!this.props.shouldSync) this.synced = true;\n\n        if (Math.abs(this.props.offset) < 0.1 && this.waveform.isPlaying()) {\n            this.numSuccessful++;\n            if (Math.abs(this.props.offset) < 0.05) this.numSuccessful++;\n            // if (Math.abs(this.props.offset) < 0.01) this.numSuccessful++;\n            if (this.numSuccessful >= 3) {\n                this.synced = true;\n            }\n\n            // if (this.numSuccessful < 5) {\n            //     console.log(this.props.deckName, \"-------------------num succesfull:\", this.numSuccessful, this.props.offset, Math.abs(this.props.offset), Math.abs(this.props.offset) < 0.1);\n            //     if (this.synced) {\n            //         console.log(this.props.deckName, \"-------------------SYNCEDDDDD\");\n            //     }\n            // }\n        }\n\n        if (this.props.offset !== prevProps.offset &&\n            this.waveform.getCurrentTime() - this.lastAdjustTime > 5 &&\n            Math.abs(this.props.offset) >= 0.05 &&\n            !this.synced) {\n            this.numSuccessful = 0;\n            console.log(this.props.deckName, \"-> about to sync\");\n            if (this.waveform.getCurrentTime() + this.props.offset > 1 && this.props.offset != 0) {\n                this.lastAdjustTime = this.waveform.getCurrentTime();\n                let adjustedOffset = this.props.offset;\n                this.totalOffset = this.props.offset;\n                console.log(\"%%%   \", this.props.deckName, \"total offset:\", this.totalOffset, \"which is\", this.totalOffset / barSize, \"bars\");\n                let desiredTime = this.waveform.getCurrentTime() + this.props.offset;\n                console.log(\"%%%   \", this.props.deckName, \" song pos was at:\", this.waveform.getCurrentTime(), \"we need:\", desiredTime);\n                this.waveform.pause();\n                this.waveform.skip(adjustedOffset);\n                this.waveform.playPause();\n                console.log(\"%%%   \", this.props.deckName, \" now we are at:\", this.waveform.getCurrentTime(), \"difference is:\", desiredTime - this.waveform.getCurrentTime(), \"offset diff:\", (this.props.offset - desiredTime - this.waveform.getCurrentTime()));\n            } else {\n                console.log(this.props.deckName, \"-> didn't sync \");\n            }\n        }\n    }\n\n    analyzeData() {\n        let sectionArray = this.props.songAnalysis.data.sections;\n        let baselineLoudness = this.props.songAnalysis.data.track.loudness;\n        let allBars = this.props.songAnalysis.data.bars;\n        let bpm = this.props.songAnalysis.data.track.tempo;\n        let timeSig = Math.round(this.props.songAnalysis.data.track.time_signature);\n\n        let songSections = [];\n        let numSections = sectionArray.length;\n        let currSection = 0;\n\n        // song analysis variables\n        let numDrops = 0;\n        let firstDropConfidence = 0;\n        let sumDropConfidence = 0;\n        let mostConfidentDrop = 0;\n\n        let numComedowns = 0;\n        let firstComedownConfidence = 0;\n        let sumComedownConfidence = 0;\n        let mostConfidentComedown = 0;\n\n        // get an array of when all bars start\n        let barStartArray = []\n    \n        let bar = this.props.songAnalysis.data.bars[0].duration;\n        let barConfidence = 0;\n        allBars.forEach(e => {\n            if (e.confidence > barConfidence) {\n                bar = e.duration;\n                barConfidence = e.confidence;\n            }\n        })\n        barSize = bar;\n        let barlength32 = bar * 2;\n        let actuallength32 = bar * 4;\n        let songDuration = this.props.songAnalysis.data.track.duration;\n        let startingPoint = 0;\n        let songBeginPoint = allBars[0].start;\n\n        let num32Bar = ((songDuration) / barlength32);\n\n        for (let a = 0; a <= num32Bar; a++) {\n            barStartArray.push(((a) * barlength32));\n        }\n\n        let calibrationArray = [];\n\n        let numCalibrationChunks = (songDuration) / bar;\n\n        for (let c = 0; c <= numCalibrationChunks; c++) {\n            calibrationArray.push(((c) * bar));\n        }\n\n\n        for (let b = 0; b < calibrationArray.length - 1; b++) {\n            let barColor = (b % 2 ? \"rgba(255, 60, 54,0.05)\" : \"rgba(46, 255, 154,0.05)\");\n            let barRegion = {\n                start: calibrationArray[b],\n                end: calibrationArray[b + 1],\n                color: barColor,\n                drag: false,\n                resize: false,\n                computed: {}\n            };\n            this.waveform.addRegion(barRegion);\n        }\n\n        sectionArray.forEach(e => {\n            currSection++;\n            let sectionType = REGULAR;\n            let is32length = false;\n\n            let comparisonLoudness = (e.loudness - baselineLoudness) / baselineLoudness;\n           \n            // IF BEGINNING OF SONG\n            if (songSections.length === 0) {\n                sectionType = BEGIN;\n            }\n\n            // IF LOUD === DROP\n            if (comparisonLoudness < 0) {\n                sectionType = DROP;\n            }\n\n            // IF LAST SONG WAS DROP AND DIFFERENTIAL OF THIS IS NEGATIVE === COMEDOWN\n            let diff = 0;\n            if (songSections.length > 0) {\n                diff = songSections[songSections.length - 1].computed.comparisonLoudness - comparisonLoudness;\n                if (songSections[songSections.length - 1].sectionType === DROP) {\n                    if (sectionType === DROP) {\n                        sectionType = UNSURE;\n                    } else {\n                        sectionType = COMEDOWN\n                    }\n                }\n            }\n            // For song analysis only\n            if (sectionType === DROP) {\n\n                if (numDrops === 0) {\n                    firstDropConfidence = e.confidence;\n                }\n                if (e.confidence > mostConfidentDrop) {\n                    mostConfidentDrop = e.confidence;\n                }\n                numDrops++\n                sumDropConfidence += e.confidence;\n            }\n            if (sectionType === COMEDOWN) {\n                // console.log(\"comedown\")\n                if (numComedowns === 0) { // Sets this as the first comedown \n                    firstComedownConfidence = e.confidence;\n                }\n                if (e.confidence > mostConfidentComedown && currSection !== numSections) {\n                    mostConfidentComedown = e.confidence; // Sets this as the most confident comedown\n                }\n\n                numComedowns++;\n                sumComedownConfidence += e.confidence;\n            }\n\n            let beginpoint = e.start;\n            let endpoint = e.start + e.duration;\n            let closestEnd = closest(endpoint, barStartArray);\n            let closestBegin = closest(beginpoint, barStartArray);\n            let offsetBegin = closestBegin - beginpoint;\n            let offsetEnd = closestEnd - endpoint;\n            let acceptedConformEnd = false;\n            let acceptedConformBegin = false;\n\n            beginpoint = closestBegin;\n            endpoint = closestEnd;\n\n\n            let sizeComparison = ((endpoint - beginpoint) / barlength32).toPrecision(2); // checks if section is of calculated 32bar length\n            if (sizeComparison % 1) {\n                is32length = true;\n            }\n\n            let randomColor = 'rgba(162,254,231,0.3)';\n            switch (sectionType) {\n                case \"\":\n                    break;\n                case BEGIN:\n                    // toLoop = true;\n                    randomColor = 'rgba(50,255,155,0.3)';\n                    if (is32length) {\n                        randomColor = 'rgba(100,255,55,0.3)';\n                    }\n                    break;\n                case DROP:\n                    randomColor = 'rgba(237,61,155,0.3)';\n                    if (is32length) {\n                        randomColor = 'rgba(255,31,105,0.3)';\n                    }\n                    break;\n                case COMEDOWN:\n                    randomColor = 'rgba(123,215,255,0.3)'\n                    if (is32length) {\n                        randomColor = 'rgba(50,150,255,0.3)'\n                    }\n                    break;\n                case UNSURE:\n                    randomColor = 'rgba(34,1,255,0.2)'\n                    if (is32length) {\n                        randomColor = 'rgba(0,255,150,0.2)'\n                    }\n                    break;\n                default:\n                    break;\n            }\n\n            let goodForMix = false;\n            if (sectionType !== DROP) {\n                if (comparisonLoudness > 0 && comparisonLoudness < 0.1) {\n                    randomColor = 'rgba(218, 165, 32,0.3)';\n                    goodForMix = true;\n                } else if (sectionType === BEGIN) {\n                    randomColor = 'rgba(218, 165, 32,0.3)';\n                    goodForMix = true;\n                }\n            }\n            let analysisSection = {\n                sectionType: sectionType,\n                begin: beginpoint,\n                endpoint: endpoint,\n                computed: {\n                    comparisonLoudness: comparisonLoudness,\n                    differential: diff,\n                    sectionConfidence: e.confidence, // todo left off here! i was completing up the separation from analysis to reconnect \n                    conformedBegin: acceptedConformBegin,\n                    conformedEnd: acceptedConformEnd,\n                    oBegin: offsetBegin,\n                    oEnd: offsetEnd\n                },\n                sizeComparison: sizeComparison,\n                is32: is32length,\n                sectionColor: randomColor,\n                goodForMix: goodForMix\n            }\n            songSections.push(analysisSection);\n        })\n\n        if (songSections.length > 2) {\n            console.log(\"sec1:\", songSections[0].sizeComparison, \"sec2:\", songSections[1].sizeComparison);\n            console.log(\"sec1:\", songSections[0].is32, \"sec2:\", songSections[1].is32);\n            if ((songSections[0].sizeComparison == 4) || (songSections[0].sizeComparison == 2 && songSections[1].sizeComparison == 2)) {\n                console.log(\"CASE A START POS\");\n                this.setState({\n                    startingPos: 0\n                })\n            } else if (songSections[0].sizeComparison == 2.0) { // todo make this if songSections[1].sizeComparison is a multiple of 4\n                console.log(\"CASE B START POS\");\n                console.log(\"mult of 4?\", songSections[1].sizeComparison % 4);\n                this.setState({\n                    startingPos: songSections[0].endpoint\n                })\n            } else {\n                console.log(\"CASE C START POS\");\n            }\n        }\n\n        return songSections;\n    }\n\n    reconnectAudio() {\n        this.state.audioElement.crossOrigin = \"anonymous\";\n\n        // LOWPASS\n        let lowpass = this.waveform.backend.ac.createBiquadFilter();\n        lowpass.frequency.value = this.state.audioSettings.lowpassF || 11000;\n        lowpass.type = \"lowpass\";\n        lowpass.Q.value = 5;\n        this.setState({\n            lowpassNode: lowpass\n        });\n\n        // HIGHPASS\n        let highpass = this.waveform.backend.ac.createBiquadFilter();\n        highpass.frequency.value = this.state.audioSettings.highpassF || 0;\n        highpass.type = \"highpass\";\n        highpass.Q.value = 5;\n        this.setState({\n            highpassNode: highpass\n        });\n\n        // GAIN\n        let gain = this.waveform.backend.ac.createGain();\n        gain.value = this.state.audioSettings.gain || 0.01;\n        this.setState({\n            gainNode: gain\n        });\n        this.waveform.backend.setFilter(lowpass, highpass);\n\n        if (this.props.songAnalysis !== 'NOTFOUND') {\n\n            let analyzed = this.analyzeData();\n\n            //! Getting the best of each region\n            let bestReg;\n            let bestDrop;\n            let bestComedown;\n            let bestOverall;\n\n            let bestRegNum = 0;\n            let bestDropNum = 0;\n            let bestComedownNum = 0;\n            let bestOverallNum = 0;\n\n            let bestRegColor = \"rgb(158, 31, 255)\" // royal purple\n            let bestDropColor = \"rgb(242, 123, 31)\"; // orange\n            let bestComedownColor = \"rgb(185, 245, 66)\"; // lime\n            let bestOverallColor = \"rgb(66, 245, 191)\"; // teal\n            let cs = 0; // currsection\n            analyzed.forEach(e => {\n                // console.log(e);\n                if (e.sectionConfidence > bestOverallNum) {\n                    bestOverallNum = e.sectionConfidence;\n                    bestOverall = cs;\n                }\n\n                switch (e.sectionType) {\n                    case DROP:\n                        if (e.sectionConfidence > bestDropNum) {\n                            bestDropNum = e.sectionConfidence;\n                            bestDrop = cs;\n                        }\n                        break;\n                    case REGULAR:\n                        if (e.sectionConfidence > bestRegNum) {\n                            bestRegNum = e.sectionConfidence;\n                            bestReg = cs;\n                        }\n                        break;\n                    case COMEDOWN:\n                        if (e.sectionConfidence > bestComedownNum) {\n                            bestComedownNum = e.sectionConfidence;\n                            bestComedown = cs;\n                        }\n                        break;\n                    default:\n                        break;\n                }\n                cs++;\n            })\n            let cs1 = 0;\n            analyzed.forEach(section => {\n                let thisSectionColor = section.sectionColor;\n                let isBest = false;\n                switch (section.sectionType) {\n                    case DROP:\n                        section.endpoint -= 0.1;\n                        if (cs1 === bestDrop) {\n                            thisSectionColor = bestDropColor;\n                            isBest = true;\n                        }\n                        break;\n                    case REGULAR:\n                        if (cs1 === bestReg) {\n                            thisSectionColor = bestRegColor;\n                            isBest = true;\n                        }\n                        break;\n                    case COMEDOWN:\n                        if (cs1 === bestComedown) {\n                            thisSectionColor = bestComedownColor;\n                            isBest = true;\n                        }\n                        break;\n                    default:\n                        break;\n                }\n\n                if (cs1 === bestOverall) {\n                    thisSectionColor = bestOverallColor;\n                }\n\n                let region = {\n                    start: section.begin,\n                    end: section.endpoint,\n                    attributes: section.computed,\n                    data: section,\n                    color: thisSectionColor,\n                    drag: false,\n                    resize: false,\n                    isBest: isBest\n                }\n                this.waveform.addRegion(region);\n                cs1++;\n            })\n        }\n        this.waveform.on('region-in', e => {\n            this.props.hitBar();\n            if (e.data.sectionType !== undefined) { // has data!\n                if (e.data.sectionType === DROP) {\n                    this.numDropsPassed++;\n                }\n            }\n        })\n\n        this.waveform.on('region-out', e => {\n            let thisSection = e.data;\n            let computed = thisSection.computed;\n            if (computed) {\n                this.setState({\n                    currSec: thisSection.sectionType,\n                    currSectionAnalysis: {\n                        begin: thisSection.begin,\n                        endpoint: thisSection.endpoint,\n                        comparisonLoudness: computed.comparisonLoudness,\n                        differential: computed.differential,\n                        sectionConfidence: computed.sectionConfidence,\n                        conformedBegin: computed.comformedBegin,\n                        conformedEnd: computed.comformedEnd,\n                        oBegin: computed.oBegin,\n                        oEnd: computed.oEnd,\n                        sectionColor: thisSection.sectionColor,\n                        goodForMix: thisSection.goodForMix,\n                        isBest: thisSection.isBest,\n                        sizeComparison: thisSection.sizeComparison,\n                        is32: thisSection.is32\n                    }\n                })\n\n                if (thisSection.sectionType === DROP && this.numDropsPassed > 1 && this.props.otherReady) {\n                    this.props.playOtherTrack();\n                    this.fadeOutSong();\n                }\n            } else {\n                this.props.hitBar();\n            }\n        });\n\n        this.waveform.on('ready', e => {\n            console.log(\"------ READY TO GO! 1 ------\");\n            this.state.audioCtx.resume();\n            if (!this.waveform.isPlaying()) {\n                this.playPause();\n                this.props.prepared();\n            }\n            this.waveform.setVolume(0.1);\n        });\n\n        this.waveform.on('play', e => {\n            console.log(this.props.deckName, \" JUST STARTED PLAYING GONNA FADE IT IN NOW OK\");\n            this.waveform.setVolume(0.1);\n            this.fadeInSong();\n        })\n    }\n\n    playPause() {\n        // check if context is in suspended state (autoplay policy)\n        if (this.state.audioCtx.state === 'suspended') {\n            this.state.audioCtx.resume();\n\n        }\n        this.waveform.play(this.state.startingPos);\n        if (this.state.playing !== this.waveform.isPlaying()) {\n            this.setState({\n                playing: this.waveform.isPlaying()\n            });\n        }\n    }\n\n    changeFilter(amount) {\n        if (amount <= 14000) {\n            this.state.audioSettings.lowpassF = amount;\n            this.state.lowpassNode.frequency.value = amount;\n        } else if (amount >= 20000) {\n            let highpassAmount = amount - 20000;\n            this.state.audioSettings.highpassF = highpassAmount;\n            this.state.highpassNode.frequency.value = this.state.audioSettings.highpassF;\n        } else {\n            this.state.audioSettings.lowpassF = 30000;\n            this.state.lowpassNode.frequency.value = this.state.audioSettings.lowpassF;\n            this.state.audioSettings.highpassF = 0;\n            this.state.highpassNode.frequency.value = this.state.audioSettings.highpassF;\n        }\n    }\n\n    changeGain(amount) {\n        // console.log(\"this ran\")\n        this.setState({\n            audioSettings: {\n                gain: (amount / 100).toPrecision(2)\n            }\n        })\n        this.waveform.setVolume((amount / 100).toPrecision(2) || 1);\n    }\n\n    handlePosChange(e) {\n        this.setState({\n            pos: e\n        });\n    }\n\n    fadeOutSong() {\n        console.log(\"fading out\");\n        this.fadingOut = true;\n        this.waveform.setVolume(lerp(this.waveform.getVolume(), 0, Math.max(this.waveform.getVolume() / 2), 0.1, this.props.deckName));\n        this.state.lowpassNode.frequency.value -= (this.state.lowpassNode.frequency.value / 10);\n        if (this.waveform.getVolume() < 0.2) this.waveform.setVolume(this.waveform.getVolume() - 0.03);\n        if (this.waveform.getVolume() > 0.001) {\n            setTimeout(() => {\n                this.fadeOutSong();\n            }, 1000);\n        } else {\n            console.log(\">>>>>>>   >>> \", this.props.deckName, \" FADED OUT_________\");\n            this.fadingOut = false;\n            this.waveform.setVolume(0);\n            this.waveform.pause();\n            this.props.finished();\n        }\n    }\n\n    fadeInSong() {\n        console.log(\"*****\", this.props.deckName, \"fading in\", this.props.recommendedVolume);\n        // todo something with this.props.recommendedVolume\n        // if (!this.props.recommendedVolume) { // TODO PASS IN PROP TO NORMALIZE VOLUME AMONGST BOTH SONGS\n        //     this.waveform.setVolume(1); \n        // } else {\n        //     this.waveform.setVolume(this.props.recommendedVolume);\n        // }\n        this.fadingIn = true;\n        console.log(this.props.recommendedVolume);\n        this.waveform.setVolume(lerp(this.waveform.getVolume(), this.props.recommendedVolume, Math.min((this.waveform.getVolume()) / 4), 0.05, this.props.deckName));\n        // if (this.waveform.getVolume() < 0.2) this.waveform.setVolume(this.waveform.getVolume() - 0.03);\n        if (this.waveform.getVolume() < this.props.recommendedVolume - 0.1) {\n            setTimeout(() => {\n                this.fadeInSong();\n            }, 1000);\n        } else {\n            console.log(\">>>>>>>  !!!  >>> \", this.props.deckName, \" FADED IN_________!!!!\");\n            this.fadingIn = false;\n            this.waveform.setVolume(this.props.recommendedVolume);\n        }\n    }\n\n    render() {\n        return (\n            <>\n                <div className={\"deck\"}>\n                    <img src={this.props.songImage.url}/>\n                        {this.props.songName !== \"\" && <h3>{this.props.songName} by {this.props.songArtist}</h3>}\n                    <div id=\"waveform\" />\n                    <div id=\"wave-timeline\" />\n                    {/* {this.props.trackImage && <image src={'https://i.scdn.co/image/ab67616d00001e02f198c232cd71f317559dc081'}></image>} */}\n                    {/* {this.props.trackImage} */}\n                    {/* <Knob size={70} numTicks={70} degrees={260} min={0} max={100} value={50} color={true} onChange={this.changeGain} />\n                    <label>GAIN</label>\n                    <Knob size={70} numTicks={70} degrees={260} min={1000} max={30000} value={15000} color={true} onChange={this.changeFilter} />\n                    <label>FILTER</label> */}\n                    {/* <button className={\"playButton\"} onClick={() => { this.playPause() }}>{this.state.playing ? \"Pause\" : \"Play\"}</button> */}\n                    \n                </div>\n            </>\n        );\n    }\n}\n\n\nfunction closest(needle, haystack) {\n    let closeGrain = 100000000000000;\n    let grainCloseness = 100000000000000;\n    haystack.forEach(grain => {\n        let thisCloseness = Math.abs(needle - grain)\n        if (Math.abs(needle - grain) < grainCloseness) {\n            grainCloseness = thisCloseness;\n            closeGrain = grain;\n        }\n    })\n    return closeGrain;\n}\n\nfunction lerp(start, end, amt, deckname) {\n    console.log(deckname, \"lerped this:\", start, end, amt, \"to:\", (1 - amt) * start + amt * end);\n    return (1 - amt) * start + amt * end\n}\n\n","/Users/parssa/Desktop/repos/mixbot/src/frontend_components/Knob.js",[],["127","128"],{"ruleId":"129","replacedBy":"130"},{"ruleId":"131","replacedBy":"132"},{"ruleId":"133","severity":1,"message":"134","line":1,"column":16,"nodeType":"135","messageId":"136","endLine":1,"endColumn":24},{"ruleId":"133","severity":1,"message":"137","line":1,"column":26,"nodeType":"135","messageId":"136","endLine":1,"endColumn":35},{"ruleId":"133","severity":1,"message":"138","line":2,"column":8,"nodeType":"135","messageId":"136","endLine":2,"endColumn":16},{"ruleId":"133","severity":1,"message":"139","line":10,"column":7,"nodeType":"135","messageId":"136","endLine":10,"endColumn":18},{"ruleId":"133","severity":1,"message":"140","line":47,"column":14,"nodeType":"135","messageId":"136","endLine":47,"endColumn":26},{"ruleId":"133","severity":1,"message":"141","line":64,"column":14,"nodeType":"135","messageId":"136","endLine":64,"endColumn":29},{"ruleId":"133","severity":1,"message":"142","line":1,"column":8,"nodeType":"135","messageId":"136","endLine":1,"endColumn":13},{"ruleId":"133","severity":1,"message":"143","line":4,"column":16,"nodeType":"135","messageId":"136","endLine":4,"endColumn":19},{"ruleId":"133","severity":1,"message":"144","line":4,"column":32,"nodeType":"135","messageId":"136","endLine":4,"endColumn":39},{"ruleId":"145","severity":1,"message":"146","line":114,"column":8,"nodeType":"147","endLine":114,"endColumn":23,"suggestions":"148"},{"ruleId":"145","severity":1,"message":"149","line":116,"column":15,"nodeType":"150","endLine":124,"endColumn":6},{"ruleId":"145","severity":1,"message":"151","line":124,"column":8,"nodeType":"147","endLine":124,"endColumn":36,"suggestions":"152"},{"ruleId":"133","severity":1,"message":"153","line":31,"column":5,"nodeType":"135","messageId":"136","endLine":31,"endColumn":18},{"ruleId":"145","severity":1,"message":"154","line":64,"column":5,"nodeType":"135","endLine":64,"endColumn":14,"suggestions":"155"},{"ruleId":"133","severity":1,"message":"156","line":148,"column":14,"nodeType":"135","messageId":"136","endLine":148,"endColumn":32},{"ruleId":"133","severity":1,"message":"157","line":165,"column":14,"nodeType":"135","messageId":"136","endLine":165,"endColumn":32},{"ruleId":"158","severity":1,"message":"159","line":275,"column":27,"nodeType":"160","messageId":"161","endLine":275,"endColumn":29},{"ruleId":"158","severity":1,"message":"159","line":275,"column":47,"nodeType":"160","messageId":"161","endLine":275,"endColumn":49},{"ruleId":"158","severity":1,"message":"159","line":279,"column":27,"nodeType":"160","messageId":"161","endLine":279,"endColumn":29},{"ruleId":"158","severity":1,"message":"159","line":279,"column":47,"nodeType":"160","messageId":"161","endLine":279,"endColumn":49},{"ruleId":"133","severity":1,"message":"134","line":1,"column":16,"nodeType":"135","messageId":"136","endLine":1,"endColumn":24},{"ruleId":"133","severity":1,"message":"162","line":9,"column":12,"nodeType":"135","messageId":"136","endLine":9,"endColumn":19},{"ruleId":"145","severity":1,"message":"163","line":50,"column":8,"nodeType":"147","endLine":50,"endColumn":13,"suggestions":"164"},{"ruleId":"145","severity":1,"message":"165","line":66,"column":8,"nodeType":"147","endLine":66,"endColumn":19,"suggestions":"166"},{"ruleId":"129","replacedBy":"167"},{"ruleId":"131","replacedBy":"168"},{"ruleId":"133","severity":1,"message":"169","line":2,"column":8,"nodeType":"135","messageId":"136","endLine":2,"endColumn":12},{"ruleId":"133","severity":1,"message":"170","line":7,"column":7,"nodeType":"135","messageId":"136","endLine":7,"endColumn":16},{"ruleId":"171","severity":1,"message":"172","line":130,"column":13,"nodeType":"173","endLine":130,"endColumn":23},{"ruleId":"158","severity":1,"message":"174","line":174,"column":93,"nodeType":"160","messageId":"161","endLine":174,"endColumn":95},{"ruleId":"133","severity":1,"message":"175","line":195,"column":13,"nodeType":"135","messageId":"136","endLine":195,"endColumn":16},{"ruleId":"133","severity":1,"message":"176","line":196,"column":13,"nodeType":"135","messageId":"136","endLine":196,"endColumn":20},{"ruleId":"133","severity":1,"message":"177","line":226,"column":13,"nodeType":"135","messageId":"136","endLine":226,"endColumn":27},{"ruleId":"133","severity":1,"message":"178","line":228,"column":13,"nodeType":"135","messageId":"136","endLine":228,"endColumn":26},{"ruleId":"133","severity":1,"message":"179","line":229,"column":13,"nodeType":"135","messageId":"136","endLine":229,"endColumn":27},{"ruleId":"133","severity":1,"message":"180","line":292,"column":21,"nodeType":"135","messageId":"136","endLine":292,"endColumn":40},{"ruleId":"133","severity":1,"message":"181","line":298,"column":17,"nodeType":"135","messageId":"136","endLine":298,"endColumn":34},{"ruleId":"133","severity":1,"message":"182","line":303,"column":21,"nodeType":"135","messageId":"136","endLine":303,"endColumn":44},{"ruleId":"133","severity":1,"message":"183","line":310,"column":17,"nodeType":"135","messageId":"136","endLine":310,"endColumn":38},{"ruleId":"158","severity":1,"message":"159","line":398,"column":49,"nodeType":"160","messageId":"161","endLine":398,"endColumn":51},{"ruleId":"158","severity":1,"message":"159","line":398,"column":90,"nodeType":"160","messageId":"161","endLine":398,"endColumn":92},{"ruleId":"158","severity":1,"message":"159","line":398,"column":129,"nodeType":"160","messageId":"161","endLine":398,"endColumn":131},{"ruleId":"158","severity":1,"message":"159","line":403,"column":55,"nodeType":"160","messageId":"161","endLine":403,"endColumn":57},{"ruleId":"171","severity":1,"message":"172","line":418,"column":9,"nodeType":"173","endLine":418,"endColumn":32},{"ruleId":"171","severity":1,"message":"172","line":618,"column":13,"nodeType":"173","endLine":618,"endColumn":37},{"ruleId":"171","severity":1,"message":"172","line":619,"column":13,"nodeType":"173","endLine":619,"endColumn":45},{"ruleId":"171","severity":1,"message":"172","line":622,"column":13,"nodeType":"173","endLine":622,"endColumn":37},{"ruleId":"171","severity":1,"message":"172","line":623,"column":13,"nodeType":"173","endLine":623,"endColumn":46},{"ruleId":"171","severity":1,"message":"172","line":625,"column":13,"nodeType":"173","endLine":625,"endColumn":37},{"ruleId":"171","severity":1,"message":"172","line":626,"column":13,"nodeType":"173","endLine":626,"endColumn":45},{"ruleId":"171","severity":1,"message":"172","line":627,"column":13,"nodeType":"173","endLine":627,"endColumn":37},{"ruleId":"171","severity":1,"message":"172","line":628,"column":13,"nodeType":"173","endLine":628,"endColumn":46},{"ruleId":"171","severity":1,"message":"172","line":652,"column":9,"nodeType":"173","endLine":652,"endColumn":41},{"ruleId":"184","severity":1,"message":"185","line":694,"column":21,"nodeType":"186","endLine":694,"endColumn":58},{"ruleId":"129","replacedBy":"187"},{"ruleId":"131","replacedBy":"188"},"no-native-reassign",["189"],"no-negated-in-lhs",["190"],"no-unused-vars","'useState' is defined but never used.","Identifier","unusedVar","'useEffect' is defined but never used.","'Dropdown' is defined but never used.","'euroHouseID' is assigned a value but never used.","'genreChanged' is defined but never used.","'playlistChanged' is defined but never used.","'React' is defined but never used.","'end' is defined but never used.","'pattern' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'videoIDtoMP3'. Either include it or remove the dependency array.","ArrayExpression",["191"],"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching","ArrowFunctionExpression","React Hook useEffect has missing dependencies: 'createSearchQuery' and 'getYoutubeVideo'. Either include them or remove the dependency array.",["192"],"'deck1playtime' is assigned a value but never used.","React Hook useEffect contains a call to 'setClock'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [clock] as a second argument to the useEffect Hook.",["193"],"'setDeckOnePlaytime' is defined but never used.","'setDeckTwoPlaytime' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'playing' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'volume'. Either include it or remove the dependency array. You can also do a functional update 'setVolume(v => ...)' if you only need 'volume' in the 'setVolume' call.",["194"],"React Hook useEffect has a missing dependency: 'handlePlayPause'. Either include it or remove the dependency array.",["195"],["189"],["190"],"'Knob' is defined but never used.","'tempTrack' is assigned a value but never used.","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","Expected '!==' and instead saw '!='.","'bpm' is assigned a value but never used.","'timeSig' is assigned a value but never used.","'actuallength32' is assigned a value but never used.","'startingPoint' is assigned a value but never used.","'songBeginPoint' is assigned a value but never used.","'firstDropConfidence' is assigned a value but never used.","'sumDropConfidence' is assigned a value but never used.","'firstComedownConfidence' is assigned a value but never used.","'sumComedownConfidence' is assigned a value but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement",["189"],["190"],"no-global-assign","no-unsafe-negation",{"desc":"196","fix":"197"},{"desc":"198","fix":"199"},{"desc":"200","fix":"201"},{"desc":"202","fix":"203"},{"desc":"204","fix":"205"},"Update the dependencies array to be: [chosenVideoID, videoIDtoMP3]",{"range":"206","text":"207"},"Update the dependencies array to be: [name, artists, duration_ms, createSearchQuery, getYoutubeVideo]",{"range":"208","text":"209"},"Add dependencies array: [clock]",{"range":"210","text":"211"},"Update the dependencies array to be: [url, volume]",{"range":"212","text":"213"},"Update the dependencies array to be: [handlePlayPause, isPlaying]",{"range":"214","text":"215"},[3800,3815],"[chosenVideoID, videoIDtoMP3]",[4098,4126],"[name, artists, duration_ms, createSearchQuery, getYoutubeVideo]",[2109,2109],", [clock]",[1849,1854],"[url, volume]",[2436,2447],"[handlePlayPause, isPlaying]"]