[{"/Users/parssa/Desktop/code/mixbot/src/index.js":"1","/Users/parssa/Desktop/code/mixbot/src/reportWebVitals.js":"2","/Users/parssa/Desktop/code/mixbot/src/App.js":"3","/Users/parssa/Desktop/code/mixbot/src/Mixbot.js":"4","/Users/parssa/Desktop/code/mixbot/src/helper_classes/Gateway.js":"5","/Users/parssa/Desktop/code/mixbot/src/frontend_components/UpdateMixBot.js":"6","/Users/parssa/Desktop/code/mixbot/src/TrackPlayer.js":"7","/Users/parssa/Desktop/code/mixbot/src/TrackSelector.js":"8","/Users/parssa/Desktop/code/mixbot/src/frontend_components/Queue.js":"9","/Users/parssa/Desktop/code/mixbot/src/frontend_components/MixConfig.js":"10","/Users/parssa/Desktop/code/mixbot/src/Brain.js":"11","/Users/parssa/Desktop/code/mixbot/src/helper_classes/Analyzer.js":"12","/Users/parssa/Desktop/code/mixbot/src/Deck.js":"13","/Users/parssa/Desktop/code/mixbot/src/helper_classes/TrackFinder.js":"14","/Users/parssa/Desktop/code/mixbot/src/api/Credentials.js":"15","/Users/parssa/Desktop/code/mixbot/src/api/youtubeVideoContent.js":"16","/Users/parssa/Desktop/code/mixbot/src/api/youtube.js":"17","/Users/parssa/Desktop/code/mixbot/src/api/keys.js":"18"},{"size":500,"mtime":1611123834829,"results":"19","hashOfConfig":"20"},{"size":362,"mtime":1611123834830,"results":"21","hashOfConfig":"20"},{"size":1592,"mtime":1611123834784,"results":"22","hashOfConfig":"20"},{"size":5356,"mtime":1611123834785,"results":"23","hashOfConfig":"20"},{"size":2831,"mtime":1611123834829,"results":"24","hashOfConfig":"20"},{"size":863,"mtime":1611123834828,"results":"25","hashOfConfig":"20"},{"size":9757,"mtime":1612160202671,"results":"26","hashOfConfig":"20"},{"size":7110,"mtime":1613614409747,"results":"27","hashOfConfig":"20"},{"size":792,"mtime":1611123834828,"results":"28","hashOfConfig":"20"},{"size":678,"mtime":1611123834828,"results":"29","hashOfConfig":"20"},{"size":1153,"mtime":1611123834785,"results":"30","hashOfConfig":"20"},{"size":8257,"mtime":1611123834829,"results":"31","hashOfConfig":"20"},{"size":17863,"mtime":1612160181577,"results":"32","hashOfConfig":"20"},{"size":5684,"mtime":1613615499844,"results":"33","hashOfConfig":"20"},{"size":192,"mtime":1611124090826,"results":"34","hashOfConfig":"20"},{"size":767,"mtime":1611123834786,"results":"35","hashOfConfig":"20"},{"size":535,"mtime":1611123834786,"results":"36","hashOfConfig":"20"},{"size":354,"mtime":1611123834786,"results":"37","hashOfConfig":"20"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},"fowgb5",{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"40"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"40"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"40"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"78","usedDeprecatedRules":"40"},"/Users/parssa/Desktop/code/mixbot/src/index.js",[],["79","80"],"/Users/parssa/Desktop/code/mixbot/src/reportWebVitals.js",[],"/Users/parssa/Desktop/code/mixbot/src/App.js",[],"/Users/parssa/Desktop/code/mixbot/src/Mixbot.js",[],"/Users/parssa/Desktop/code/mixbot/src/helper_classes/Gateway.js",[],"/Users/parssa/Desktop/code/mixbot/src/frontend_components/UpdateMixBot.js",[],"/Users/parssa/Desktop/code/mixbot/src/TrackPlayer.js",["81","82","83","84","85","86","87"],"import React, { useEffect, useState } from 'react';\nimport Deck from \"./Deck\";\nimport './css_files/Queue.scss';\nimport { loadTrack, nextSongInQueue } from \"./Mixbot\";\n\nlet deck1startTime = 0;\nlet deck2startTime = 0;\n\nlet lastTrackSet = 0;\nlet mainTrack = 0;\n\nlet deck1lastBar = 0;\nlet deck2lastBar = 0;\n\nlet deckOneGlow = 9;\nlet deckTwoGlow = 9;\n\nlet equalizedGainVal = -10;\n\nexport default function TrackPlayer({ newThought, masterPlay }) {\n    const [clock, setClock] = useState();\n\n    const [deck1Song, setDeck1Song] = useState('');\n    const [deck2Song, setDeck2Song] = useState('');\n\n    const [deck1BPM, setDeck1BPM] = useState(0);\n    const [deck2BPM, setDeck2BPM] = useState(0);\n\n    const [deck1playback, setDeck1playback] = useState(1);\n    const [deck2playback, setDeck2playback] = useState(1);\n\n    const [deck1prepared, setDeck1prepared] = useState(false);\n    const [deck2prepared, setDeck2prepared] = useState(false);\n\n    const [deck1remove, setDeck1remove] = useState(false);\n    const [deck2remove, setDeck2remove] = useState(false);\n\n    const [deck1Playing, setDeck1Playing] = useState(false);\n    const [deck2Playing, setDeck2Playing] = useState(false);\n\n    const [deck1offset, setDeck1offset] = useState(0);\n    const [deck2offset, setDeck2offset] = useState(0);\n\n    // const [deck1gain, setDeck1Gain] = useState(null); // actual volumes in db\n    // const [deck2gain, setDeck2Gain] = useState(null);\n\n    const [deck1vol, setdeck1vol] = useState(1); // relative vol 0 -1\n    const [deck2vol, setdeck2vol] = useState(1);\n\n    useEffect(() => {\n        if (!clock) {\n            let newClock = new AudioContext();\n            setClock(newClock);\n        } \n        \n        if (Math.random() > 0.5) {\n            deckOneGlow += 10;\n            if (deckOneGlow >= 360) deckOneGlow = 0;\n        } else {\n            deckTwoGlow += 10;\n            if (deckTwoGlow >= 360) deckTwoGlow = 0;\n        }\n    })\n\n    useEffect(() => {\n        if (nextSongInQueue() !== null) {\n            if ((deck1BPM == 0) && (deck1Song == '')) {\n                loadTrackA();\n            } else if ((deck2BPM == 0) && (deck2Song == '')) {\n                loadTrackB();\n            }\n        }\n    })\n\n    function loadTrackA() {\n        let newSong = loadTrack();\n        setDeck1prepared(false);\n        setDeck1Playing(false);\n        setDeck1remove(false);\n        if (newSong !== null) {\n            if (!newSong.songAnalysis.analysis) {\n                console.log(\"CASE A\", newSong);\n            } else {\n                console.log(\"CASE B\", newSong);\n            }\n            setDeck1BPM(Math.round(newSong.songAnalysis.analysis.tempo)) // terribly sus\n            let newvol = (newSong.songAnalysis.analysis.loudness / equalizedGainVal).toPrecision(5);\n            console.log(\"DECK A NEW VOLUME >>>>>>>>>>>>>>>>\", newvol);\n            setdeck1vol(newvol);\n            if (deck2Song === '') {\n                setDeck1playback(1);\n            } else {\n                if (deck2BPM !== 0) {\n                    let ratioPB = (deck2BPM / newSong.songAnalysis.analysis.tempo).toPrecision(5);\n                    setDeck1playback(ratioPB);\n                } else {\n                    setDeck1playback(1);\n                }\n            }\n            let think = \"Put \" + newSong.songName + \" on Deck A\";\n            newThought(think);\n            setDeck1Song(newSong);\n        }\n    }\n\n    function loadTrackB() {\n        let newSong = loadTrack();\n        setDeck2prepared(false);\n        setDeck2Playing(false);\n        setDeck2remove(false);\n        if (newSong !== null) {\n            \n\n            // EITHER IS newSong.songAnalysis || newSOng.songAnalysis.analysis\n            if (!newSong.songAnalysis.analysis) {\n                console.log(\"CASE A\", newSong);\n            } else {\n                console.log(\"CASE B\", newSong);\n            }\n\n            setDeck2BPM(Math.round(newSong.songAnalysis.analysis.tempo)) // terribly sus\n            let newvol = (newSong.songAnalysis.analysis.loudness / equalizedGainVal).toPrecision(5);\n            // console.log(\"DECK B NEW VOLUME >>>>>>>>>>>>>>>>\", newvol);\n            setdeck2vol(newvol);\n\n            if (deck1Song === '') {\n                setDeck2playback(1);\n            } else {\n                if (deck1BPM !== 0) {\n                    let ratio = (deck1BPM / Math.round(newSong.songAnalysis.analysis.tempo)).toPrecision(5);\n                    setDeck2playback(ratio);\n                } else {\n                    setDeck2playback(1);\n                }\n            }\n            let think = \"Put \" + newSong.songName + \" on Deck B\";\n            newThought(think);\n            setDeck2Song(newSong)\n        } else {\n            console.log(\"[WARNING] new song was null\");\n        }\n    }\n\n    function deckOneReady() {\n        if (!deck1prepared) {\n            setDeck1prepared(true);\n            if (!deck2Playing) {\n                setDeck1Playing(true);\n            }\n        }\n    }\n\n    function deckTwoReady() {\n        if (!deck2prepared) {\n            setDeck2prepared(true);\n            if (!deck1Playing) {\n                setDeck2Playing(true);\n            }\n        }\n    }\n\n    function playTrackTwo() {\n        if (deck2prepared) {\n            setDeck2Playing(true);\n            setDeck2prepared(false);\n            if (lastTrackSet === 0) {\n                lastTrackSet = 2;\n                mainTrack = 1;\n            }\n        }\n    }\n\n    function playTrackOne() {\n        if (deck1prepared) {\n            setDeck1Playing(true);\n            setDeck1prepared(false);\n            if (lastTrackSet === 0) {\n                lastTrackSet = 1;\n                mainTrack = 1;\n            }\n\n        }\n    }\n\n    function hitBarD1() {\n        deck1lastBar = clock.currentTime;\n        if (deck2Playing) {\n            setDeck1offset(deck2lastBar - deck1lastBar);\n        }\n    }\n\n    function hitBarD2() {\n        deck2lastBar = clock.currentTime;\n        if (deck1Playing) {\n            setDeck2offset(deck1lastBar - deck2lastBar);\n        }\n    }\n\n    function changeTrackA() {\n        mainTrack = 2;\n        setDeck2playback(1);\n        loadTrackA();\n    }\n\n    function changeTrackB() {\n        mainTrack = 1;\n        setDeck1playback(1);\n        loadTrackB();\n    }\n\n    function takeOutA() {\n        if (deck1Playing) setDeck1remove(true);\n        \n    }\n\n    function takeOutB() {\n        if (deck2Playing) setDeck2remove(true);\n    }\n\n    return (\n        <>\n            <div className={\"djboard\"}>\n                <div className={\"boardpanel\"} style={deck1Playing ? { boxShadow: `0 3px 100px hsla(${deckOneGlow}, 100%, 64%, 0.302)` } : { boxShadow: `0 0 0 hsla(${deckOneGlow}, 100%, 64%, 0.302)` }}>\n                    <h3>DECK A</h3>\n                    {deck1Song !== '' && <Deck\n                        \n                        thisSong={deck1Song.songURL}\n                        songName={deck1Song.songName}\n                        songArtist={deck1Song.songArtists[0].name}\n                        songImage={deck1Song.trackImage}\n                        songAnalysis={deck1Song.songAnalysis}\n                        \n                        playbackRate={deck1playback}\n                        prepared={deckOneReady}\n                        play={deck1Playing}\n                        startTime={deck1startTime}\n                        playOtherTrack={playTrackTwo}\n                        hitBar={hitBarD1}\n                        \n                        offset={deck1offset}\n                        deckName={\"Deck A\"}\n                        finished={changeTrackA}\n                        recommendedVolume={1}\n                        shouldSync={mainTrack !== 1}\n                        otherReady={deckTwoReady}\n                        waveformID={\"waveformA\"}\n                        bpm={deck1BPM}\n                        newThought={newThought}\n                        shouldRemove={deck1remove}\n                        removeOther={takeOutB}\n                        otherPlaying={deck2Playing}\n\n                        masterPlay={masterPlay}\n                    />\n                    }\n\n                </div>\n                <div className={\"boardpanel\"} style={deck2Playing ? { boxShadow: `0 3px 100px hsla(${deckTwoGlow}, 100%, 64%, 0.302)` } : { boxShadow: `0 0 0 hsla(${deckTwoGlow}, 100%, 64%, 0.302)` }}>\n                    <h3 style={{ textAlign: 'right' }}>DECK B</h3>\n                    {deck2Song !== '' && <Deck\n                        thisSong={deck2Song.songURL}\n                        songName={deck2Song.songName}\n                        songArtist={deck2Song.songArtists[0].name}\n                        songImage={deck2Song.trackImage}\n                        songAnalysis={deck2Song.songAnalysis}\n                        \n                        playbackRate={deck2playback}\n                        prepared={deckTwoReady}\n                        play={deck2Playing}\n                        startTime={deck2startTime}\n                        playOtherTrack={playTrackOne}\n                        hitBar={hitBarD2}\n                        offset={deck2offset}\n                        deckName={\"Deck B\"}\n                        finished={changeTrackB}\n                        recommendedVolume={1}\n                        shouldSync={mainTrack !== 2}\n                        otherReady={deckOneReady}\n                        waveformID={\"waveformB\"}\n                        bpm={deck2BPM}\n                        newThought={newThought}\n                        shouldRemove={deck2remove}\n                        removeOther={takeOutA}\n                        otherPlaying={deck1Playing}\n\n                        masterPlay={masterPlay}\n                    />}\n                </div>\n            </div>\n        </>\n    );\n}","/Users/parssa/Desktop/code/mixbot/src/TrackSelector.js",["88","89"],"import React, { useState, useEffect, useCallback } from 'react';\nimport { Credentials } from './api/Credentials';\nimport axios from 'axios';\nimport TrackFinder from \"./helper_classes/TrackFinder\";\nimport { thoughtType, trackAlreadyIn, tracklistSize } from \"./Mixbot\";\nimport { Gateway } from './helper_classes/Gateway';\n\nconst MixType = {\n    EURO_HOUSE: 1,\n    CHILL_HOUSE: 2,\n    TECH_HOUSE: 3,\n}\n\nlet currentMix = null; // meant to be a mixType\nconst euroHouseMix_1 = \"2818tC1Ba59cftJJqjWKZi\";\nconst euroHouseMix_2 = \"1fWDDXepy50hFXLhwGR5xP\";\nconst chillMix_1 = \"52yAobXW9CokfKnLhe3C8Z\";\nconst chillMix_2 = \"6el7EnAXJJ2kvnoBDvWXvk\";\nconst techHouseMix_1 = \"7HRYveKYzLJFqb1PTJejoL\";\n\nlet chosenPlaylist = null;\n\nlet gateway = new Gateway();\nlet offset = 0;\nlet numChosen = 0;\nlet numLimit = 100;\n\nfunction getMixText() {\n    switch (currentMix) {\n        case MixType.EURO_HOUSE:\n            return \"Euro House Mix\";\n        case MixType.TECH_HOUSE:\n            return \"Tech House Mix\";\n        case MixType.CHILL_HOUSE:\n            return \"Chill House Mix\";\n        default:\n            break;\n    }\n}\n\nfunction TrackSelector({ addToQueue, addMoreSongs, newThought, mixChosen }) {\n    const spotify = Credentials();\n    const [token, setToken] = useState('');\n    const [playlist, setPlaylist] = useState({ selectedPlaylist: null, listOfPlaylistFromAPI: [] });\n    const [tracks, setTracks] = useState({ selectedTrack: '', listOfTracksFromAPI: [] });\n    const [trackDetail, setTrackDetail] = useState(null);\n    const [chosenMix, setChosenMix] = useState(false);\n\n    useEffect(() => {                                       // used for verification\n        axios('https://accounts.spotify.com/api/token', {\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n                'Authorization': 'Basic ' + btoa(spotify.ClientId + ':' + spotify.ClientSecret)\n            },\n            data: 'grant_type=client_credentials',\n            method: 'POST'\n        })\n            .then(tokenResponse => {\n                setToken(tokenResponse.data.access_token);\n            });\n\n    }, [spotify.ClientId, spotify.ClientSecret]);\n\n\n\n    function changeChosen(playlist) {\n        if (playlist === 1) { // euro house\n            currentMix = MixType.EURO_HOUSE;\n            chosenPlaylist = Math.random() > 0.5 ? euroHouseMix_1 : euroHouseMix_2;\n        } else if (playlist === 2) {\n            currentMix = MixType.CHILL_HOUSE;\n            chosenPlaylist = Math.random() > 0.5 ? chillMix_1 : chillMix_2;\n        } else {\n            currentMix = MixType.TECH_HOUSE;\n            chosenPlaylist = techHouseMix_1;\n        }\n\n        setPlaylist({ selectedPlaylist: chosenPlaylist });\n        setChosenMix(true);\n    }    \n\n    function playlistSearchClicked(e) {\n        e.preventDefault();\n        numChosen = 0;\n        axios(`https://api.spotify.com/v1/playlists/${playlist.selectedPlaylist}/tracks?limit=${numLimit}`, {\n            method: 'GET',\n            headers: {\n                'Authorization': 'Bearer ' + token\n            }, \n            params: {\n                offset: offset\n            }\n        }).then(tracksResponse => {\n            setTracks({\n                selectedTrack: tracks.selectedTrack,\n                listOfTracksFromAPI: tracksResponse.data.items\n            })\n\n            mixChosen(getMixText());\n        });\n    }\n\n    const selectTrack = useCallback((val) => {\n        if (!trackAlreadyIn(val)) {\n            const currentTracks = [...tracks.listOfTracksFromAPI];\n            const trackInfo = currentTracks.filter(t => t.track.id === val);\n            setTrackDetail(trackInfo[0].track);\n        }\n    });\n\n    const chooseSong = useCallback((choiceSelections) => {\n        let selected = choiceSelections[Math.floor(Math.random() * (choiceSelections.length - 1))];\n        console.log(\"random choice:\", selected);\n        selectTrack(selected.track.id);\n    });\n\n    useEffect(() => {\n        if (tracks.listOfTracksFromAPI.length > 0) {\n            if (trackDetail == null && addMoreSongs) {\n                chooseSong(tracks.listOfTracksFromAPI)\n            }\n        }\n    }, [tracks, trackDetail, addMoreSongs, chooseSong])\n\n    async function addSongToTracklist(songName, songArtists, duration, songURL, trackID, trackImage, youtubeVideoID, fromDatabase) {\n        if (!trackAlreadyIn(trackID)) {\n            await getAudioAnalysis(trackID, songName, songArtists, duration, songURL, trackImage, youtubeVideoID, fromDatabase);\n        } else {\n            setTrackDetail(null);\n        }\n    }\n\n    async function addSongAnalysisToDatabase(dbObj) {\n        // !temporarily removed\n        // let dbAnalysis = {\n        //     songID: songID,\n        //     songName: songName,\n        //     analysis: songAnalysis\n        // }\n        // await gateway.addToAnalysis(dbObj);\n        \n    }\n\n    const getAudioAnalysis = async (id, songName, songArtists, duration, songURL, trackImage, youtubeVideoID, fromDatabase) => {\n        let analysisInDB = await gateway.checkAnalysisDB(id);\n        let takenFromDB = !analysisInDB;\n        if (takenFromDB) {\n            analysisInDB = await gateway.getSpotifyAnalysis(id, token);\n            let dbAnalysis = {\n                songID: id,\n                songName: songName,\n                analysis: analysisInDB\n            }\n            analysisInDB = dbAnalysis;\n        }\n        \n        await addToQueue(songName, songArtists, duration, songURL, analysisInDB, trackImage, id, youtubeVideoID, fromDatabase); // ! todo added \"Await\" this \n        addSongAnalysisToDatabase(analysisInDB);\n        numChosen++;\n        setTrackDetail(null);\n        if (numChosen >= numLimit - 10) {\n            console.log(\"Going to refresh the playlist\");\n            offset += numLimit;\n            playlistSearchClicked();\n        }\n    }\n\n    const couldntBeFound = (alreadyDB) => {\n        if (!alreadyDB) {\n            const think = \"Unable to add \" + trackDetail.name;\n            newThought(think, thoughtType.FAILURE);\n        }\n        setTrackDetail(null);\n    }\n\n    return (\n        <div className=\"selector-wrapper\">\n\n            <h1>Select a mix</h1>\n            {chosenMix && <h2>{getMixText()}</h2>}\n            <div className=\"playlist-select\">\n                {tracklistSize() === 0 && <button onClick={() => changeChosen(1)}>EURO HOUSE</button>}\n                {tracklistSize() === 0 && <button onClick={() => changeChosen(2)}>CHILL HOUSE</button>}\n                {tracklistSize() === 0 && <button onClick={() => changeChosen(3)}>TECH HOUSE</button>}\n            </div>\n            \n            <form onSubmit={playlistSearchClicked}>\n                {chosenMix && tracklistSize() === 0 && <button className=\"begin-mix\">Begin mix</button>}\n                <div style={{ marginTop: \"4em\" }}>\n                    <TrackFinder\n                        trackDetail={trackDetail}\n                        foundSong={addSongToTracklist}\n                        cantFind={couldntBeFound}/>\n                </div>\n            </form>\n        </div>\n    );\n}\n\nexport default TrackSelector;\n","/Users/parssa/Desktop/code/mixbot/src/frontend_components/Queue.js",[],"/Users/parssa/Desktop/code/mixbot/src/frontend_components/MixConfig.js",[],"/Users/parssa/Desktop/code/mixbot/src/Brain.js",[],"/Users/parssa/Desktop/code/mixbot/src/helper_classes/Analyzer.js",[],"/Users/parssa/Desktop/code/mixbot/src/Deck.js",["90","91","92","93","94","95","96","97","98","99"],"import React, { Component } from 'react';\nimport WaveSurfer from 'wavesurfer.js';\nimport RegionPlugin from 'wavesurfer.js/dist/plugin/wavesurfer.regions.min.js';\nimport './css_files/Deck.scss';\nimport { SectionType } from './helper_classes/Analyzer';\nimport { thoughtType } from './Mixbot';\n\nlet xhr = { cache: 'default', mode: 'cors', method: 'GET', credentials: 'same-origin', redirect: 'follow', referrer: 'client', headers: [{ 'Access-Control-Allow-Origin': '*' }] };\nlet isMasterPaused = false;\n\nexport default class Deck extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            pos: 0,\n            locked: false,\n            scheduledDemise: false,\n            currSec: \"NOT PLAYING\",\n            playing: false,\n            trackName: this.props.songName,\n            trackArtist: this.props.songArtist,\n            audioCtx: new AudioContext(),\n            audioSettings: {\n                gain: 1,\n                lowpassF: 11000,\n                highpassF: 0,\n                high: 1,\n                mid: 1,\n                low: 1,\n                playbackRate: this.props.playbackRate\n            },\n            currSectionAnalysis: {\n                begin: NaN,\n                endpoint: NaN,\n                comparisonLoudness: NaN,\n                differential: NaN,\n                sectionConfidence: NaN,\n                conformedBegin: NaN,\n                conformedEnd: NaN,\n                oBegin: NaN,\n                oEnd: NaN,\n                sectionColor: `rgb(255,255,255)`,\n                goodForMix: false,\n                isBest: false\n            },\n            startingPos: 0\n        };\n\n        this.waveSurferOptions = {\n            container: `#${this.props.waveformID}`,\n            waveColor: \"#ffffff\",\n            cursorColor: \"tomato\",\n            hideScrollbar: true,\n            normalize: true,\n            height: 70,\n            barWidth: 1,\n            barHeight: 0.5, // the height of the wave\n            barRadius: 2,\n            plugins: [\n                RegionPlugin.create(),\n            ],\n            xhr: xhr\n        }\n\n        this.lastAdjustTime = 0;\n        this.synced = false;\n        this.fadingOut = false;\n        this.fadingIn = false;\n        this.totalOffset = 0;\n        this.numSuccessful = 0;\n        this.numDropsPassed = 0;\n\n        this.playPause = this.playPause.bind(this);\n        this.fadeOutSong = this.fadeOutSong.bind(this);\n        this.changeFilter = this.changeFilter.bind(this);\n        this.changeGain = this.changeGain.bind(this);\n        this.reconnectAudio = this.reconnectAudio.bind(this);\n        this.handlePosChange = this.handlePosChange.bind(this);\n        this.takeOutSong = this.takeOutSong.bind(this);\n        this.normalizePlayback = this.normalizePlayback.bind(this);\n    }\n\n    componentDidMount() {\n        this.waveform = WaveSurfer.create(this.waveSurferOptions);\n\n        this.waveform.on('error', e => {\n            console.error(e);\n        })     \n        this.waveform.load(this.props.thisSong);\n        this.waveform.setPlaybackRate(this.props.playbackRate);\n        this.reconnectAudio();\n    }\n\n    componentDidUpdate(prevProps) {\n        if (this.waveform.getVolume() < this.props.recommendedVolume &&\n            !this.fadingIn &&\n            !this.fadingOut) {\n            this.waveform.setVolume(this.props.recommendedVolume);\n        }\n        \n        if (this.props.thisSong !== prevProps.thisSong) { \n            this.waveform.pause();\n            this.synced = false;\n            this.numSuccessful = 0;\n            this.totalOffset = 0;\n            this.fadingOut = false;\n            this.fadingIn = false;\n            this.numDropsPassed = 0;\n            \n            // !Prone to memory leak ngl 0.o\n            this.waveform.destroy();\n\n            this.waveform = WaveSurfer.create(this.waveSurferOptions);\n            \n            this.waveform.on('error', e => {\n                console.log(\"hit error:\", e);\n            })\n\n            let dummy = new Audio(this.props.thisSong);\n            this.waveform.load(dummy.src);\n            this.waveform.setPlaybackRate(this.props.playbackRate);\n\n            this.reconnectAudio();\n        } \n\n        if (this.state.audioCtx.state !== 'suspended') {\n            if (this.props.play !== this.waveform.isPlaying()) {\n                if (!this.props.play) {\n                    console.log(\"~~~ SHOULD BE PAUSED NGL ~~~\");\n                    this.waveform.pause();\n                } else {\n                    this.playPause();\n                }\n            }\n        }\n\n        if (!this.props.shouldSync) {\n            this.synced = true; // If this is the main track, don't sync it\n            this.normalizePlayback();\n            \n        }\n\n        // If the offset between tracks is under 0.1 seconds and this is playing, this track is succesful\n        // ! The margin of error of 0.1s is needed due to timing issues with WebAudio\n        if (Math.abs(this.props.offset) < 0.1 && this.waveform.isPlaying()) {\n            this.numSuccessful++;\n            if (Math.abs(this.props.offset) < 0.05) this.numSuccessful++;\n            if (this.numSuccessful >= 3) {\n                this.synced = true;\n            }\n        }\n\n        /**\n         * IF:\n         *  1) New offset passed in\n         *  2) It has been over 5 seconds since the last time it was adjusted\n         */\n        if (this.props.offset !== prevProps.offset &&\n            this.waveform.getCurrentTime() - this.lastAdjustTime > 5 &&\n            Math.abs(this.props.offset) >= 0.05 &&\n            !this.synced) {\n            this.numSuccessful = 0;\n            console.log(this.props.deckName, \"-> about to sync\");\n            if (this.waveform.getCurrentTime() + this.props.offset > 1 && this.props.offset != 0) {\n                this.lastAdjustTime = this.waveform.getCurrentTime();\n                let adjustedOffset = this.props.offset;\n                this.totalOffset = this.props.offset;\n                let desiredTime = this.waveform.getCurrentTime() + this.props.offset;\n                this.waveform.pause();\n                this.waveform.skip(adjustedOffset);\n                this.waveform.playPause();\n                console.log(\"%%%   \", this.props.deckName, \" now we are at:\", this.waveform.getCurrentTime(), \"difference is:\", desiredTime - this.waveform.getCurrentTime(), \"offset diff:\", (this.props.offset - desiredTime - this.waveform.getCurrentTime()));\n            } else {\n                console.log(this.props.deckName, \"-> didn't sync \");\n            }\n        }\n\n        if (this.props.shouldRemove && !this.fadingOut && !this.shouldSync && this.props.otherPlaying) {\n            this.takeOutSong();\n        }\n\n        if (this.props.masterPlay !== prevProps.masterPlay) {\n            if (this.props.masterPlay) {\n                this.waveform.pause();\n                isMasterPaused = true;\n            } else {\n                if (this.waveform.isPlaying() !== this.props.play) {\n                    this.waveform.play();\n                } else {\n                    isMasterPaused = false;\n                }\n            }\n        }\n    }\n\n    normalizePlayback() {\n        if (this.waveform.getPlaybackRate() !== 1) {\n            let newRate = lerp(this.waveform.getPlaybackRate(), 1, 0.1, this.props.deckName);\n            if (isFinite(newRate)) this.waveform.setVolume(newRate);\n            if (Math.abs(1 - this.waveform.getPlaybackRate()) < 0.1) this.waveform.setPlaybackRate(1);\n            else this.normalizePlayback();\n        }\n    }\n\n    reconnectAudio() {\n        // console.log(\"reconnecting audio\");\n        // LOWPASS\n        let lowpass = this.waveform.backend.ac.createBiquadFilter();\n        lowpass.frequency.value = this.state.audioSettings.lowpassF || 11000;\n        lowpass.type = \"lowpass\";\n        lowpass.Q.value = 5;\n        this.setState({\n            lowpassNode: lowpass\n        });\n\n        // HIGHPASS\n        let highpass = this.waveform.backend.ac.createBiquadFilter();\n        highpass.frequency.value = this.state.audioSettings.highpassF || 0;\n        highpass.type = \"highpass\";\n        highpass.Q.value = 5;\n        this.setState({\n            highpassNode: highpass\n        });\n\n        // GAIN\n        let gain = this.waveform.backend.ac.createGain();\n        gain.value = this.state.audioSettings.gain || 0.01;\n        this.setState({\n            gainNode: gain\n        });\n        this.waveform.backend.setFilter(lowpass, highpass);\n        if (this.props.songAnalysis !== 'NOTFOUND') {\n            let analyzed = this.props.songAnalysis.analysis.songSections;\n            \n            analyzed.forEach(section => {\n                let region = {\n                    start: section.begin,\n                    end: section.endpoint,\n                    attributes: section.computed,\n                    data: section,\n                    color: section.sectionColor,\n                    drag: false,\n                    resize: false,\n                }\n                this.waveform.addRegion(region);\n            })\n\n            let bars = this.props.songAnalysis.analysis.bars;\n            bars.forEach(b => {\n                this.waveform.addRegion(b);\n            })\n            this.setState({\n                startingPos: this.props.songAnalysis.startPos\n            })\n        }\n        this.waveform.on('region-in', e => {\n            this.props.hitBar();\n            console.log(\">>>> HIT BAR : DIFF\", e.data.computed.differential, \"COMPLOUD\", e.data.computed.comparisonLoudness);\n            if (e.data.computed.differential < 0) {\n                if (this.props.otherReady && (this.waveform.getCurrentTime() / this.waveform.getDuration() > 0.4)) {\n                    this.props.playOtherTrack();                                                 \n                    console.log(this.props.deckName, \"good mixing spot\");\n                }\n            }\n            if (e.data.sectionType !== undefined) { // has data!\n                if (e.data.sectionType === SectionType.DROP) {\n                    this.numDropsPassed++;\n                }\n            }\n        })\n\n        this.waveform.on('region-out', e => {\n            let thisSection = e.data;\n            let computed = thisSection.computed;\n            if (computed) {\n                this.setState({\n                    currSec: thisSection.sectionType,\n                    currSectionAnalysis: {\n                        begin: thisSection.begin,\n                        endpoint: thisSection.endpoint,\n                        comparisonLoudness: computed.comparisonLoudness,\n                        differential: computed.differential,\n                        sectionConfidence: computed.sectionConfidence,\n                        conformedBegin: computed.comformedBegin,\n                        conformedEnd: computed.comformedEnd,\n                        oBegin: computed.oBegin,\n                        oEnd: computed.oEnd,\n                        sectionColor: thisSection.sectionColor,\n                        goodForMix: thisSection.goodForMix,\n                        isBest: thisSection.isBest,\n                        sizeComparison: thisSection.sizeComparison,\n                        is32: thisSection.is32\n                    }\n                })\n                console.log(this.props.deckName, \" HAS FINISHED\", this.waveform.getCurrentTime() / this.waveform.getDuration(), \"OF ITS SONG\");\n                if (this.props.otherReady && (this.waveform.getCurrentTime() / this.waveform.getDuration() > 0.4)) {\n                    if ((thisSection.sectionType === SectionType.DROP && this.numDropsPassed > 0) || thisSection.sectionType === SectionType.COMEDOWN) {\n                        this.props.playOtherTrack();                                                 \n                    } else if (this.waveform.getCurrentTime() / this.waveform.getDuration() > 0.7) {\n                        this.props.playOtherTrack();\n                    }\n                }\n            } else {\n                this.props.hitBar();\n            }\n        });\n\n        this.waveform.on('ready', e => {\n            console.log(\"------ READY TO GO! 1 ------\");\n            this.state.audioCtx.resume();\n            if (!this.waveform.isPlaying()) {\n                this.playPause();\n                this.props.prepared();\n            }\n            this.waveform.setVolume(0.01);\n        });\n\n        this.waveform.on('play', e => {\n            \n            if (this.props.play) {\n                // console.log(this.props.deckName, \" JUST STARTED PLAYING GONNA FADE IT IN NOW OK\");\n                if (isMasterPaused) {\n                    console.log(\"was a master pause\");\n                    isMasterPaused = false;\n                } else {\n                    this.waveform.setVolume(0.01);\n                    let think = \"Fading in \" + this.props.deckName;\n                    this.props.newThought(think, thoughtType.MIX);\n                    this.fadeInSong();\n                }\n            }\n            \n        })\n\n    }\n\n    takeOutSong() {\n        this.fadeOutSong();\n        let think = \"Fading out \" + this.props.deckName;\n        this.props.newThought(think, thoughtType.MIX);\n    }\n\n    playPause() {\n        // check if context is in suspended state (autoplay policy)\n        if (this.state.audioCtx.state === 'suspended') {\n            this.state.audioCtx.resume();\n\n        }\n        this.waveform.play(this.state.startingPos);\n        if (this.state.playing !== this.waveform.isPlaying()) {\n            this.setState({\n                playing: this.waveform.isPlaying()\n            });\n        }\n    }\n\n    changeFilter(amount) {\n        if (amount <= 14000) {\n            this.state.audioSettings.lowpassF = amount;\n            this.state.lowpassNode.frequency.value = amount;\n        } else if (amount >= 20000) {\n            let highpassAmount = amount - 20000;\n            this.state.audioSettings.highpassF = highpassAmount;\n            this.state.highpassNode.frequency.value = this.state.audioSettings.highpassF;\n        } else {\n            this.state.audioSettings.lowpassF = 30000;\n            this.state.lowpassNode.frequency.value = this.state.audioSettings.lowpassF;\n            this.state.audioSettings.highpassF = 0;\n            this.state.highpassNode.frequency.value = this.state.audioSettings.highpassF;\n        }\n    }\n\n    changeGain(amount) {\n        this.setState({\n            audioSettings: {\n                gain: (amount / 100).toPrecision(2)\n            }\n        })\n    }\n\n    handlePosChange(e) {\n        this.setState({\n            pos: e\n        });\n    }\n\n    fadeOutSong() {\n        this.fadingOut = true;\n        this.waveform.setVolume(lerp(this.waveform.getVolume(), 0, Math.min(this.waveform.getVolume() / 3), 0.1, this.props.deckName));\n        this.state.lowpassNode.frequency.value -= (this.state.lowpassNode.frequency.value / 10);\n        if (this.waveform.getVolume() < 0.2) this.waveform.setVolume(this.waveform.getVolume() - 0.03);\n        if (this.waveform.getVolume() > 0.01) {\n            setTimeout(() => {\n                this.fadeOutSong();\n            }, 1000);\n        } else {\n            console.log(\">>>>>>>   >>> \", this.props.deckName, \" FADED OUT_________\");\n            this.fadingOut = false;\n            this.waveform.setVolume(0);\n            this.waveform.pause();\n            this.props.finished();\n        }\n    }\n\n    fadeInSong() {\n        this.fadingIn = true;\n        let newVol = lerp(this.waveform.getVolume(), this.props.recommendedVolume, Math.min((this.waveform.getVolume()) / 4), 0.03, this.props.deckName);\n        if (isFinite(newVol)) {\n            if (newVol >= this.props.recommendedVolume) this.waveform.setVolume(this.props.recommendedVolume);\n            else this.waveform.setVolume(newVol);\n        }\n        \n        if (this.waveform.getVolume() < this.props.recommendedVolume - 0.05) {   // TODO TWEAK THIS BASED ON IF MAIN TRACK OR NOT\n            setTimeout(() => {\n                this.fadeInSong();\n            }, 1000);\n        } else {\n            console.log(\">>>>>>>  !!!  >>> \", this.props.deckName, \" FADED IN_________!!!!\");\n            this.fadingIn = false;\n            this.waveform.setVolume(this.props.recommendedVolume);\n            this.props.removeOther();\n        }\n    }\n\n    skipSong() {\n        this.takeOutSong();\n        this.props.playOtherTrack();\n    }\n\n    render() {\n        return (\n            <>\n                <div className={\"deck\"}>\n                    \n                    <img src={this.props.songImage.url} alt=\"\" />\n                    <div className={\"deck-content\"}>\n                        <div className={\"deck-text\"}>\n                            {this.props.songName !== \"\" && <h2>{this.props.songName}</h2>}\n                            {this.props.songName !== \"\" && <h3>{this.props.songArtist}</h3>}\n                        </div>\n                        <div className={\"deck-text\"}>\n                            <h4>{this.props.bpm} BPM</h4>\n                            <button onClick={() => this.skipSong()}>SKIP SONG</button>\n                            {/* <h4>{this.props.bpm} BPM</h4> */}\n                        </div>\n                        <div id={`${this.props.waveformID}`} />\n                    </div>\n                    \n                    {/* <Knob size={70} numTicks={70} degrees={260} min={0} max={100} value={50} color={true} onChange={this.changeGain} /> */}\n                    {/* <Knob size={70} numTicks={70} degrees={260} min={1000} max={30000} value={15000} color={true} onChange={this.changeFilter} /> */}\n                </div>\n            </>\n        );\n    }\n}\n\nfunction lerp(start, end, amt, deckname) {\n    // console.log(deckname, \"lerped this:\", start, end, amt, \"to:\", (1 - amt) * start + amt * end);\n    return (1 - amt) * start + amt * end\n}\n\n","/Users/parssa/Desktop/code/mixbot/src/helper_classes/TrackFinder.js",["100","101","102","103","104"],"/Users/parssa/Desktop/code/mixbot/src/api/Credentials.js",[],"/Users/parssa/Desktop/code/mixbot/src/api/youtubeVideoContent.js",[],"/Users/parssa/Desktop/code/mixbot/src/api/youtube.js",[],"/Users/parssa/Desktop/code/mixbot/src/api/keys.js",["105","106","107"],"const youtubeKey1 = \"AIzaSyC6F5gJnOX3mS2dl5-b_82PQ2ow7Xikuw8\"; // NotMixBot\n\nconst youtubeKey2 = \"AIzaSyCt7QrJ3-iInh6822WGi3Igo8J9gpH2WyA\"; // ThirdBot\n\nconst youtubeKey3 = \"AIzaSyBpT_RmX3P3wp_OMxiJT0SZIhkqFwMfVrA\"; // not set up yet\n\nconst youtubeKey4 = \"AIzaSyDgc98evXaE_C01NhK6ls2n7ZDkR - vg6sU\"; // backupPlan\n\n\nexport const currentKey = youtubeKey2;",{"ruleId":"108","replacedBy":"109"},{"ruleId":"110","replacedBy":"111"},{"ruleId":"112","severity":1,"message":"113","line":47,"column":12,"nodeType":"114","messageId":"115","endLine":47,"endColumn":20},{"ruleId":"112","severity":1,"message":"116","line":48,"column":12,"nodeType":"114","messageId":"115","endLine":48,"endColumn":20},{"ruleId":"117","severity":1,"message":"118","line":50,"column":5,"nodeType":"114","endLine":50,"endColumn":14,"suggestions":"119"},{"ruleId":"120","severity":1,"message":"121","line":67,"column":27,"nodeType":"122","messageId":"123","endLine":67,"endColumn":29},{"ruleId":"120","severity":1,"message":"121","line":67,"column":47,"nodeType":"122","messageId":"123","endLine":67,"endColumn":49},{"ruleId":"120","severity":1,"message":"121","line":69,"column":34,"nodeType":"122","messageId":"123","endLine":69,"endColumn":36},{"ruleId":"120","severity":1,"message":"121","line":69,"column":54,"nodeType":"122","messageId":"123","endLine":69,"endColumn":56},{"ruleId":"117","severity":1,"message":"124","line":103,"column":25,"nodeType":"114","endLine":103,"endColumn":36},{"ruleId":"117","severity":1,"message":"124","line":111,"column":24,"nodeType":"114","endLine":111,"endColumn":35},{"ruleId":"120","severity":1,"message":"125","line":164,"column":93,"nodeType":"122","messageId":"123","endLine":164,"endColumn":95},{"ruleId":"126","severity":1,"message":"127","line":359,"column":13,"nodeType":"128","endLine":359,"endColumn":37},{"ruleId":"126","severity":1,"message":"127","line":360,"column":13,"nodeType":"128","endLine":360,"endColumn":45},{"ruleId":"126","severity":1,"message":"127","line":363,"column":13,"nodeType":"128","endLine":363,"endColumn":37},{"ruleId":"126","severity":1,"message":"127","line":364,"column":13,"nodeType":"128","endLine":364,"endColumn":46},{"ruleId":"126","severity":1,"message":"127","line":366,"column":13,"nodeType":"128","endLine":366,"endColumn":37},{"ruleId":"126","severity":1,"message":"127","line":367,"column":13,"nodeType":"128","endLine":367,"endColumn":45},{"ruleId":"126","severity":1,"message":"127","line":368,"column":13,"nodeType":"128","endLine":368,"endColumn":37},{"ruleId":"126","severity":1,"message":"127","line":369,"column":13,"nodeType":"128","endLine":369,"endColumn":46},{"ruleId":"126","severity":1,"message":"127","line":390,"column":9,"nodeType":"128","endLine":390,"endColumn":41},{"ruleId":"112","severity":1,"message":"129","line":1,"column":8,"nodeType":"114","messageId":"115","endLine":1,"endColumn":13},{"ruleId":"112","severity":1,"message":"130","line":4,"column":17,"nodeType":"114","messageId":"115","endLine":4,"endColumn":20},{"ruleId":"112","severity":1,"message":"131","line":4,"column":33,"nodeType":"114","messageId":"115","endLine":4,"endColumn":40},{"ruleId":"117","severity":1,"message":"132","line":115,"column":8,"nodeType":"133","endLine":115,"endColumn":23,"suggestions":"134"},{"ruleId":"117","severity":1,"message":"135","line":140,"column":8,"nodeType":"133","endLine":140,"endColumn":21,"suggestions":"136"},{"ruleId":"112","severity":1,"message":"137","line":1,"column":7,"nodeType":"114","messageId":"115","endLine":1,"endColumn":18},{"ruleId":"112","severity":1,"message":"138","line":5,"column":7,"nodeType":"114","messageId":"115","endLine":5,"endColumn":18},{"ruleId":"112","severity":1,"message":"139","line":7,"column":7,"nodeType":"114","messageId":"115","endLine":7,"endColumn":18},"no-native-reassign",["140"],"no-negated-in-lhs",["141"],"no-unused-vars","'deck1vol' is assigned a value but never used.","Identifier","unusedVar","'deck2vol' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect contains a call to 'setClock'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [clock] as a second argument to the useEffect Hook.",["142"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","React Hook useCallback does nothing when called with only one argument. Did you forget to pass an array of dependencies?","Expected '!==' and instead saw '!='.","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","'React' is defined but never used.","'end' is defined but never used.","'pattern' is defined but never used.","React Hook useEffect has a missing dependency: 'videoIDtoMP3'. Either include it or remove the dependency array.","ArrayExpression",["143"],"React Hook useEffect has missing dependencies: 'cantFind', 'createSearchQuery', and 'getYoutubeVideo'. Either include them or remove the dependency array. If 'cantFind' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["144"],"'youtubeKey1' is assigned a value but never used.","'youtubeKey3' is assigned a value but never used.","'youtubeKey4' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"145","fix":"146"},{"desc":"147","fix":"148"},{"desc":"149","fix":"150"},"Add dependencies array: [clock]",{"range":"151","text":"152"},"Update the dependencies array to be: [chosenVideoID, videoIDtoMP3]",{"range":"153","text":"154"},"Update the dependencies array to be: [cantFind, createSearchQuery, getYoutubeVideo, trackDetail]",{"range":"155","text":"156"},[1925,1925],", [clock]",[4224,4239],"[chosenVideoID, videoIDtoMP3]",[5138,5151],"[cantFind, createSearchQuery, getYoutubeVideo, trackDetail]"]